<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" href="data:,">
    <title>18 TaÅŸlÄ± Dama â€“ 3D</title>
    <script type="importmap">
    {
        "imports": {
            "three":         "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
        }
    }
    </script>
    <style>
        :root {
            --sidebar-bg: #3d2b1f;
            --text-color: #f5e6d3;
            --board-bg:   #c59830;
            --btn-bg:     #5d4037;
            --btn-outline-color:  var(--board-bg);
            --btn-outline-border: var(--board-bg);
        }
        body[data-theme='light'] {
            --sidebar-bg: #ece0d3;
            --text-color: #2f241b;
            --board-bg:   #d6aa48;
            --btn-bg:     #6d4c41;
            --btn-outline-color:  #7b3e19;
            --btn-outline-border: #7b3e19;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0; padding: 0;
            display: flex; height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            color: var(--text-color);
            background: #0b0708;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        /* Aurora bg canvas */
        #bg-canvas {
            position: fixed; inset: 0;
            width: 100%; height: 100%;
            z-index: 0; pointer-events: none;
        }

        #main-wrapper { position: relative; z-index: 1; display: flex; width: 100%; height: 100%; }

        /* â”€â”€ Sidebar â”€â”€ */
        #sidebar {
            width: 280px;
            background-color: rgba(41,27,16,0.93);
            padding: 22px;
            box-shadow: 2px 0 18px rgba(0,0,0,0.6);
            display: flex; flex-direction: column; gap: 12px;
            z-index: 10; flex-shrink: 0;
        }
        body[data-theme='light'] #sidebar { background-color: rgba(230,216,200,0.93); }

        /* inner wrapper â€” flex column on all screen sizes */
        #sidebar-inner {
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex: 1;
        }

        h1 { margin: 0; color: var(--board-bg); font-size: 17px; text-transform: uppercase; letter-spacing: 2px; text-align: center; border-bottom: 2px solid #5d4037; padding-bottom: 10px; }
        .panel { background: rgba(0,0,0,0.22); padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.06); }

        .status-bar {
            display: flex; align-items: center; justify-content: center; gap: 10px;
            font-size: 1rem; font-weight: bold; text-align: center;
            padding: 10px; background: #f5e6d3; color: #3d2b1f; border-radius: 6px;
        }
        .turn-stone-dot {
            width: 22px; height: 22px; border-radius: 50%; flex-shrink: 0;
            box-shadow: 0 3px 8px rgba(0,0,0,0.5);
            transition: background 0.35s ease;
        }
        .turn-stone-dot.red   { background: radial-gradient(circle at 30% 30%, #ff8a80, #e53935 60%, #8e0000); }
        .turn-stone-dot.green { background: radial-gradient(circle at 30% 30%, #a5d6a7, #4caf50 60%, #1b5e20); }

        select, button { padding: 10px; border-radius: 6px; border: none; background: var(--btn-bg); color: white; cursor: pointer; font-weight: bold; font-family: inherit; }
        button.primary  { background: #e53935; color: white; }
        button.outline  { background: transparent; border: 2px solid var(--btn-outline-border); color: var(--btn-outline-color); }

        #combo-msg { color: #ffeb3b; font-size: 0.8rem; text-align: center; display: none; margin-top: 5px; font-weight: bold; }

        .cam-hint { font-size: 0.75rem; opacity: 0.55; text-align: center; line-height: 1.7; }

        /* â”€â”€ 3D canvas area â”€â”€ */
        #canvas-area { flex-grow: 1; position: relative; overflow: hidden; }
        #canvas-area canvas { display: block; outline: none; }

        /* â”€â”€ Winner modal â”€â”€ */
        #winner-modal {
            position: fixed; inset: 0; display: none;
            justify-content: center; align-items: center;
            background: rgba(0,0,0,0.75); z-index: 4000; padding: 20px;
        }
        #winner-modal.show { display: flex; }
        .winner-dialog {
            width: min(460px, 100%);
            background: linear-gradient(145deg, #3e316d, #2c2554);
            border: 2px solid rgba(255,255,255,0.22);
            border-radius: 18px; padding: 36px 28px 28px;
            text-align: center; box-shadow: 0 24px 60px rgba(0,0,0,0.7); color: #fff;
        }
        .winner-trophy { font-size: 3.8rem; margin-bottom: 8px; animation: trophyBounce 0.7s ease; }
        @keyframes trophyBounce {
            0%   { transform: scale(0) rotate(-15deg); opacity: 0; }
            60%  { transform: scale(1.25) rotate(5deg);  opacity: 1; }
            100% { transform: scale(1) rotate(0); }
        }
        .winner-headline { margin: 0 0 6px; font-size: 1.7rem; font-weight: 900; letter-spacing: 2px; }
        .winner-headline.red-win   { color: #ff8a80; }
        .winner-headline.green-win { color: #a5d6a7; }
        .winner-headline.ai-win    { color: #ef9a9a; }
        .winner-sub { margin: 0 0 24px; font-size: 1.05rem; opacity: 0.85; line-height: 1.5; }
        .winner-actions { display: flex; gap: 12px; justify-content: center; }
        .winner-actions button { flex: 1; max-width: 180px; padding: 12px; font-size: 0.95rem; }

        /* â”€â”€ Fireworks canvas â”€â”€ */
        #fw-canvas { position: fixed; inset: 0; width: 100%; height: 100%; pointer-events: none; z-index: 3999; display: none; }

        /* â”€â”€ How-to intro screen â”€â”€ */
        #howto-screen {
            position: fixed; inset: 0; z-index: 2000;
            display: flex; align-items: center; justify-content: center;
            padding: 18px;
            background: radial-gradient(circle at top, #4e3d85, #3e316d 50%, #2c2554);
            color: #fff;
        }
        .howto-card {
            width: min(720px, 100%); max-height: 92dvh; overflow: auto;
            border-radius: 14px; padding: 18px;
            background: rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.18);
        }
        .howto-title  { margin: 0 0 12px; text-align: center; font-size: 1.6rem; letter-spacing: 1px; }
        .howto-sub    { margin: 0 0 14px; text-align: center; opacity: 0.9; font-size: 0.95rem; }
        .howto-list   { margin: 0; padding-left: 22px; display: flex; flex-direction: column; gap: 10px; line-height: 1.45; font-size: 1rem; }
        .howto-actions { margin-top: 18px; display: flex; justify-content: center; }
        .intro-section-label { text-align: center; font-size: 0.8rem; letter-spacing: 1.5px; text-transform: uppercase; opacity: 0.65; margin: 16px 0 8px; }
        .intro-mode-btns, .intro-diff-btns { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-bottom: 6px; }
        .mode-btn { padding: 11px 26px; border-radius: 8px; border: 2px solid rgba(255,255,255,0.25); background: rgba(255,255,255,0.08); color: #fff; font-size: 1rem; font-weight: bold; cursor: pointer; transition: all 0.2s; font-family: inherit; }
        .mode-btn.active { background: #e53935; border-color: #e53935; box-shadow: 0 0 14px rgba(229,57,53,0.45); }
        .mode-btn:hover:not(.active) { background: rgba(255,255,255,0.18); }
        .diff-btn { padding: 8px 20px; border-radius: 6px; border: 2px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.07); color: #fff; font-size: 0.9rem; font-weight: bold; cursor: pointer; transition: all 0.2s; font-family: inherit; }
        .diff-btn.active { background: #5c6bc0; border-color: #7986cb; box-shadow: 0 0 10px rgba(92,107,192,0.4); }
        .diff-btn:hover:not(.active) { background: rgba(255,255,255,0.14); }
        .intro-divider { border: none; border-top: 1px solid rgba(255,255,255,0.12); margin: 16px 0; }
        .menu-info-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 6px; }
        .menu-info-item { background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.12); border-radius: 8px; padding: 8px 12px; font-size: 0.88rem; line-height: 1.5; }

        /* â”€â”€ In-game how-to modal â”€â”€ */
        #howto-modal-bg {
            position: fixed; inset: 0; z-index: 3000; display: none;
            align-items: center; justify-content: center;
            background: rgba(0,0,0,0.72); padding: 18px;
        }
        #howto-modal-bg.show { display: flex; }
        .howto-modal-card {
            width: min(680px, 100%); max-height: 90dvh; overflow-y: auto;
            border-radius: 14px; padding: 22px;
            background: linear-gradient(145deg, #3e316d, #2c2554);
            border: 1px solid rgba(255,255,255,0.18);
            color: #fff; box-shadow: 0 20px 60px rgba(0,0,0,0.7);
        }

        /* â”€â”€ Landscape lock â”€â”€ */
        #landscape-lock {
            display: none; position: fixed; inset: 0; z-index: 9999;
            background: #1a0e05; color: #f5e6d3;
            flex-direction: column; align-items: center; justify-content: center;
            gap: 20px; text-align: center; padding: 30px;
        }
        #landscape-lock.show { display: flex; }
        .lock-icon { font-size: 3.5rem; animation: rotatePhone 1.5s ease-in-out infinite alternate; }
        @keyframes rotatePhone { from { transform: rotate(0deg); } to { transform: rotate(-90deg); } }
        .lock-text { font-size: 1.15rem; font-weight: bold; line-height: 1.6; }

        /* â”€â”€ Mobile toggle bar â”€â”€ */
        #menu-toggle-bar {
            display: none;
        }

        @media (max-width: 900px) {
            body { flex-direction: column; overflow-y: auto; height: auto; }
            #main-wrapper { flex-direction: column; min-height: 100dvh; }
            #canvas-area { order: 1; flex: 1; min-height: 60dvh; }
            select, button { width: 100%; min-height: 44px; }
            .menu-info-grid { grid-template-columns: 1fr; }

            /* sidebar becomes a collapsible strip at the bottom */
            #sidebar {
                width: 100%;
                order: 2;
                padding: 0;
                gap: 0;
                overflow: hidden;
                max-height: 52px;
                transition: max-height 0.35s ease;
                flex-direction: column-reverse;
            }
            #sidebar.open {
                max-height: 600px;
            }

            /* always-visible toggle bar */
            #menu-toggle-bar {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 10px 16px;
                cursor: pointer;
                user-select: none;
                background: rgba(0,0,0,0.18);
                border-top: 1px solid rgba(255,255,255,0.08);
                min-height: 52px;
                box-sizing: border-box;
            }
            #menu-toggle-bar span {
                font-size: 0.85rem;
                font-weight: bold;
                letter-spacing: 1.5px;
                text-transform: uppercase;
                opacity: 0.85;
            }
            #menu-toggle-btn {
                width: auto !important;
                min-height: unset !important;
                padding: 6px 14px;
                font-size: 0.8rem;
                background: rgba(255,255,255,0.12);
                border: 1px solid rgba(255,255,255,0.2);
                border-radius: 20px;
                color: inherit;
            }

            /* inner content with padding */
            #sidebar-inner {
                padding: 14px;
                display: flex;
                flex-direction: column;
                gap: 12px;
            }
            /* title already shown in toggle bar on mobile */
            #sidebar-inner h1 { display: none; }
        }
    </style>
</head>
<body>

    <canvas id="bg-canvas" aria-hidden="true"></canvas>

    <!-- Landscape lock -->
    <div id="landscape-lock">
        <div class="lock-icon">ğŸ“±</div>
        <div class="lock-text">LÃ¼tfen cihazÄ±nÄ±zÄ±<br><strong>dikey konuma</strong> dÃ¶ndÃ¼rÃ¼n.<br>Oyun yatay modda Ã§alÄ±ÅŸmaz.</div>
    </div>

    <!-- Intro / howto screen -->
    <div id="howto-screen" role="dialog" aria-modal="true">
        <div class="howto-card">
            <h2 class="howto-title">18 TaÅŸlÄ± Dama â€“ 3D</h2>

            <p class="intro-section-label">Oyun Modu</p>
            <div class="intro-mode-btns">
                <button class="mode-btn" data-mode="pvp" onclick="selectIntroMode('pvp')">ğŸ‘¥ Ä°ki KiÅŸi</button>
                <button class="mode-btn active" data-mode="pve" onclick="selectIntroMode('pve')">ğŸ¤– Bilgisayara KarÅŸÄ±</button>
            </div>
            <div id="intro-diff-wrap" style="display:block;text-align:center;">
                <p class="intro-section-label" style="margin-top:10px;">Zorluk Seviyesi</p>
                <div class="intro-diff-btns">
                    <button class="diff-btn" data-level="easy"   onclick="selectIntroDiff('easy')">Kolay</button>
                    <button class="diff-btn active" data-level="medium" onclick="selectIntroDiff('medium')">Orta</button>
                    <button class="diff-btn" data-level="hard"   onclick="selectIntroDiff('hard')">Zor</button>
                </div>
            </div>

            <div class="howto-actions" style="margin-top:16px;">
                <button class="primary" style="width:100%;padding:13px;font-size:1.05rem;letter-spacing:1px;" onclick="closeHowToScreen()">â–¶ OYUNA BAÅLA</button>
            </div>

            <hr class="intro-divider">

            <p class="howto-sub" style="margin-bottom:10px;">NasÄ±l OynanÄ±r?</p>
            <ul class="howto-list">
                <li><strong>Hamle yapmak:</strong> Kendi taÅŸÄ±nÄ±za tÄ±klayÄ±n, ardÄ±ndan gitmek istediÄŸiniz boÅŸ noktaya tÄ±klayÄ±n. TaÅŸlar yalnÄ±zca Ã§izgiler Ã¼zerinde ilerler.</li>
                <li><strong>Rakip taÅŸÄ± almak:</strong> Bir rakip taÅŸÄ±nÄ±n tam karÅŸÄ±sÄ±ndaki nokta boÅŸsa Ã¼zerinden atlayarak o noktaya geÃ§er, rakip taÅŸ oyundan Ã§Ä±kar.</li>
                <li><strong>Kombo:</strong> TaÅŸ aldÄ±ktan sonra aynÄ± taÅŸla zincirleme alma fÄ±rsatÄ± Ã§Ä±karsa komboyu sÃ¼rdÃ¼rebilirsiniz.</li>
                <li><strong>Kazanma koÅŸulu:</strong> Rakibinin 18 taÅŸÄ±nÄ±n tamamÄ±nÄ± tahtadan kaldÄ±ran oyuncu kazanÄ±r.</li>
            </ul>

            <hr class="intro-divider">

            <p class="howto-sub" style="margin-bottom:10px;">3D Kamera KontrolÃ¼</p>
            <div class="menu-info-grid">
                <div class="menu-info-item">ğŸ–± <strong>Sol tÄ±k + sÃ¼rÃ¼kle</strong><br>TahtayÄ± dÃ¶ndÃ¼r</div>
                <div class="menu-info-item">ğŸ–± <strong>Tekerlek</strong><br>YaklaÅŸtÄ±r / uzaklaÅŸtÄ±r</div>
                <div class="menu-info-item">ğŸ–± <strong>SaÄŸ tÄ±k + sÃ¼rÃ¼kle</strong><br>KaydÄ±r (pan)</div>
                <div class="menu-info-item">ğŸ“± <strong>Ä°ki parmak</strong><br>DÃ¶ndÃ¼r / yaklaÅŸtÄ±r</div>
            </div>

            <hr class="intro-divider">

            <p class="howto-sub" style="margin-bottom:10px;">MenÃ¼ ButonlarÄ±</p>
            <div class="menu-info-grid">
                <div class="menu-info-item">ğŸ”„ <strong>Yeni Oyun</strong><br>TahtayÄ± sÄ±fÄ±rlar.</div>
                <div class="menu-info-item">â˜€ï¸ğŸŒ™ <strong>Tema</strong><br>AÃ§Ä±k / koyu mod.</div>
                <div class="menu-info-item">ğŸµ <strong>MÃ¼zik</strong><br>MÃ¼ziÄŸi aÃ§/kapat.</div>
                <div class="menu-info-item">â“ <strong>NasÄ±l OynanÄ±r</strong><br>KurallarÄ± tekrar gÃ¶ster.</div>
            </div>
        </div>
    </div>

    <!-- In-game how-to modal -->
    <div id="howto-modal-bg" role="dialog" aria-modal="true" onclick="closeHowtoModal(event)">
        <div class="howto-modal-card" onclick="event.stopPropagation()">
            <h2 class="howto-title" style="margin:0 0 12px;text-align:center;font-size:1.45rem;">18 TaÅŸlÄ± Dama â€“ 3D</h2>
            <p class="howto-sub" style="margin-bottom:10px;">NasÄ±l OynanÄ±r?</p>
            <ul class="howto-list">
                <li><strong>Hamle yapmak:</strong> Kendi taÅŸÄ±nÄ±za tÄ±klayÄ±n, ardÄ±ndan hedef noktaya tÄ±klayÄ±n.</li>
                <li><strong>TaÅŸ almak:</strong> Rakip taÅŸÄ±n Ã¼zerinden atlayarak o taÅŸÄ± oyundan Ã§Ä±karÄ±n.</li>
                <li><strong>Kombo:</strong> ArdÄ±ÅŸÄ±k atlamalar sÄ±ra deÄŸiÅŸtirmez.</li>
                <li><strong>Kazanma:</strong> Rakibinin tÃ¼m taÅŸlarÄ±nÄ± alan oyuncu kazanÄ±r.</li>
            </ul>
            <div class="howto-actions">
                <button class="primary" onclick="closeHowtoModal()">TAMAM</button>
            </div>
        </div>
    </div>

    <!-- Main layout -->
    <div id="main-wrapper">
        <div id="sidebar">
            <!-- Always-visible toggle bar (mobile only) -->
            <div id="menu-toggle-bar" onclick="toggleSidebar()">
                <span>18 TAÅLI DAMA 3D</span>
                <button id="menu-toggle-btn">â–² MENÃœ</button>
            </div>

            <!-- Collapsible inner content -->
            <div id="sidebar-inner">
                <h1>18 TAÅLI DAMA 3D</h1>

                <div id="status" class="status-bar">
                    <span id="turn-stone" class="turn-stone-dot red"></span>
                    SÄ±ra: <span id="turn-txt">KÄ±rmÄ±zÄ±</span>
                </div>
                <div id="combo-msg">âš¡ KOMBO DEVAM EDÄ°YOR!</div>

                <div class="panel">
                    <div id="score" style="text-align:center;font-weight:bold;color:#fff;">KÄ±rmÄ±zÄ±: 18 | YeÅŸil: 18</div>
                </div>

                <div class="panel" style="display:flex;flex-direction:column;gap:8px;">
                    <button class="primary" onclick="openIntroScreen()">ğŸ”„ YENÄ° OYUN</button>
                    <button class="outline" onclick="toggleTheme()" id="themeBtn">â˜€ï¸ GÃœNDÃœZ MODU</button>
                    <button class="outline" onclick="toggleMusic()"  id="musicBtn">ğŸµ MÃœZÄ°K AÃ‡</button>
                    <button class="outline" onclick="openHowtoModal()">â“ NASIL OYNANIR</button>
                </div>

                <div class="panel cam-hint">
                    ğŸ–± SÃ¼rÃ¼kle: DÃ¶ndÃ¼r<br>
                    ğŸ–± Tekerlek: YaklaÅŸtÄ±r<br>
                    ğŸ–± SaÄŸ tÄ±k: KaydÄ±r
                </div>
            </div>
        </div>

        <div id="canvas-area"></div>
    </div>

    <!-- Fireworks -->
    <canvas id="fw-canvas"></canvas>

    <!-- Winner modal -->
    <div id="winner-modal" role="dialog" aria-modal="true">
        <div class="winner-dialog">
            <div class="winner-trophy" id="winner-trophy">ğŸ†</div>
            <h2 id="winner-title" class="winner-headline">KAZANDINIZ!</h2>
            <p id="winner-sub" class="winner-sub">Tebrikler!</p>
            <div class="winner-actions">
                <button class="primary" onclick="closeWinnerAndGoIntro()">&#x21BA; TEKRAR OYNA</button>
            </div>
        </div>
    </div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  CONSTANTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const disabledNodes = [1, 7, 9, 17, 27, 35, 37, 43];
    const startX = 65, startY = 55, stepX = 90, stepY = 85;
    const drawnMainLinks = [
        [0,36],[0,20],[2,38],[2,42],[2,6],[3,39],[4,24],[4,20],[4,40],[5,41],
        [6,42],[6,38],[8,44],[8,24],[10,28],[11,15],[16,34],[20,36],[20,40],
        [20,24],[24,44],[24,40],[29,33],[38,42],[18,20],[24,26]
    ];

    // 3D board mapping: col â†’ X, row â†’ Z
    const SC = { sx: 1.1, sz: 1.2, ox: -4.4, oz: -2.4 };
    const SURF_Y  = 0.175;   // half of BOARD_H
    const STONE_R = 0.36;
    const BOARD_W = 9.8, BOARD_H = 0.35, BOARD_D = 5.8;

    function nodePos3D(id) {
        return new THREE.Vector3(
            (id % 9)            * SC.sx + SC.ox,
            SURF_Y,
            Math.floor(id / 9) * SC.sz + SC.oz
        );
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  GAME STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let nodes = [], adj = {};
    let state = {
        board: {}, turn: 'red', selected: null, isCombo: false,
        score: { red: 18, green: 18 }, mode: 'pve', aiLevel: 'medium',
        gameOver: false, aiMoveHistory: []
    };
    let introMode = 'pve', introDiff = 'medium';

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  AUDIO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const musicBtn        = document.getElementById('musicBtn');
    const introPlaylist   = ['intro.mp3'];
    const gamePlaylist    = ['bgm-1.mp3'];
    const audioState = {
        enabled: true, screen: 'intro', trackIndex: 0,
        bgm: new Audio(),
        sfx: {
            move:     new Audio('move.mp3'),
            capture:  new Audio('capture.mp3'),
            win:      new Audio('win.mp3'),
            click:    new Audio('click.mp3'),
            applause: new Audio('applause.mp3')
        }
    };

    function setupAudio() {
        audioState.bgm.volume = 0.35;
        audioState.bgm.preload = 'auto';
        audioState.bgm.addEventListener('ended', () => {
            if (audioState.screen === 'intro') { loadBgm('intro', 0); tryPlay(); }
            else { loadBgm('game', (audioState.trackIndex + 1) % gamePlaylist.length); tryPlay(); }
        });
        Object.values(audioState.sfx).forEach(s => { s.volume = 0.55; s.preload = 'auto'; });
        document.addEventListener('click', e => {
            if (e.target.closest('button') && audioState.enabled) playSfx('click');
        }, true);
        loadBgm('intro', 0);
        tryPlay();
        updateMusicUI();
    }

    function loadBgm(screen, index) {
        audioState.screen = screen; audioState.trackIndex = index;
        const src = screen === 'intro' ? introPlaylist[index % introPlaylist.length]
                                       : gamePlaylist[index % gamePlaylist.length];
        audioState.bgm.loop = (screen === 'game');
        audioState.bgm.src = src;
        audioState.bgm.load();
    }

    function tryPlay() {
        if (!audioState.enabled) return;
        audioState.bgm.play().catch(() => {
            const unlock = () => {
                if (audioState.enabled) audioState.bgm.play().catch(() => {});
                ['pointerdown','touchstart','keydown'].forEach(ev => window.removeEventListener(ev, unlock));
            };
            ['pointerdown','touchstart','keydown'].forEach(ev => window.addEventListener(ev, unlock, { once: true }));
        });
    }

    function switchToBgm(screen) { loadBgm(screen, 0); if (audioState.enabled) tryPlay(); }
    function toggleMusic() {
        audioState.enabled = !audioState.enabled;
        if (audioState.enabled) tryPlay(); else audioState.bgm.pause();
        updateMusicUI();
    }
    function playSfx(type) {
        const s = audioState.sfx[type]; if (!s) return;
        s.currentTime = 0; s.play().catch(() => {});
    }
    function updateMusicUI() {
        if (musicBtn) musicBtn.innerText = audioState.enabled ? 'ğŸ”‡ MÃœZÄ°K KAPAT' : 'ğŸµ MÃœZÄ°K AÃ‡';
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  THREE.JS SCENE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const canvasArea = document.getElementById('canvas-area');

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(canvasArea.clientWidth, canvasArea.clientHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.15;
    canvasArea.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0c0809);
    // no fog â€” keeps distant stars visible

    const camera = new THREE.PerspectiveCamera(
        50,
        canvasArea.clientWidth / canvasArea.clientHeight,
        0.1, 120
    );

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping    = true;
    controls.dampingFactor    = 0.07;
    controls.minPolarAngle    = 0.08;
    controls.maxPolarAngle    = Math.PI / 2.05;
    controls.minDistance      = 3;
    controls.maxDistance      = 22;
    controls.target.set(0, 0, 0);

    // â”€â”€ Camera default position per viewport â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let userMovedCamera = false;
    controls.addEventListener('start', () => { userMovedCamera = true; });

    function setCameraDefault() {
        const isMobile = window.innerWidth <= 900;
        if (isMobile) {
            // Portrait mobile: pull back so full board width fits
            camera.position.set(0, 11, 14);
        } else {
            camera.position.set(0, 7.5, 9);
        }
        controls.target.set(0, 0, 0);
        controls.update();
    }
    setCameraDefault();

    // â”€â”€ Lighting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    scene.add(new THREE.AmbientLight(0xfff5e0, 0.42));

    const dirLight = new THREE.DirectionalLight(0xfff8f0, 1.5);
    dirLight.position.set(3, 10, 6);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    dirLight.shadow.camera.near = 0.5;
    dirLight.shadow.camera.far  = 40;
    dirLight.shadow.camera.left   = -9;
    dirLight.shadow.camera.right  =  9;
    dirLight.shadow.camera.top    =  6;
    dirLight.shadow.camera.bottom = -6;
    dirLight.shadow.bias = -0.001;
    scene.add(dirLight);

    const warmLight = new THREE.PointLight(0xffa040, 1.3, 20, 1.8);
    warmLight.position.set(0, 5.5, 0);
    scene.add(warmLight);

    const rimLight = new THREE.PointLight(0x4040ff, 0.4, 28, 2);
    rimLight.position.set(-2, 5, -14);
    scene.add(rimLight);

    // â”€â”€ Board frame (dark wood base) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    {
        const geo = new THREE.BoxGeometry(BOARD_W + 0.65, 0.14, BOARD_D + 0.65);
        const mat = new THREE.MeshStandardMaterial({ color: 0x3d2010, roughness: 0.82, metalness: 0.06 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.y = -(BOARD_H / 2 + 0.07);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        scene.add(mesh);
    }

    // â”€â”€ Board surface â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const boardGeo = new THREE.BoxGeometry(BOARD_W, BOARD_H, BOARD_D);
    const boardMat = new THREE.MeshStandardMaterial({ color: 0xc08818, roughness: 0.55, metalness: 0.09 });
    const boardMesh = new THREE.Mesh(boardGeo, boardMat);
    boardMesh.castShadow = true;
    boardMesh.receiveShadow = true;
    scene.add(boardMesh);

    // Board visible edges
    const boardEdges = new THREE.LineSegments(
        new THREE.EdgesGeometry(boardGeo),
        new THREE.LineBasicMaterial({ color: 0x3d2b1f })
    );
    scene.add(boardEdges);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  GRAPH BUILDING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const nodeHitMeshes = [];    // for raycasting click detection

    function gcd(a, b) { return b ? gcd(b, a % b) : a; }

    function addNode(id, x, y) {
        if (disabledNodes.includes(id)) return;
        nodes[id] = { id, x, y };
        adj[id] = [];
    }

    function link(u, v) {
        if (disabledNodes.includes(u) || disabledNodes.includes(v)) return;
        if (!adj[u]) adj[u] = [];
        if (!adj[v]) adj[v] = [];
        if (!adj[u].includes(v)) adj[u].push(v);
        if (!adj[v].includes(u)) adj[v].push(u);
    }

    function addPath(u, v) {
        const r1 = Math.floor(u/9), c1 = u%9;
        const r2 = Math.floor(v/9), c2 = v%9;
        const dr = r2-r1, dc = c2-c1;
        const steps = gcd(Math.abs(dr), Math.abs(dc));
        const sr = dr/steps, sc = dc/steps;
        let last = u;
        for (let i = 1; i <= steps; i++) {
            const nid = (r1 + i*sr)*9 + (c1 + i*sc);
            if (!disabledNodes.includes(nid)) { link(last, nid); last = nid; }
        }
    }

    // Shared geometries / materials
    const nodeDotGeo = new THREE.CylinderGeometry(0.10, 0.10, 0.03, 14);
    const nodeDotMat = new THREE.MeshStandardMaterial({ color: 0x281006, roughness: 0.5, metalness: 0.35 });

    const hitCircleGeo = new THREE.CircleGeometry(0.70, 12);
    hitCircleGeo.rotateX(-Math.PI / 2);
    const hitCircleMat = new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide });

    const lineMat = new THREE.LineBasicMaterial({ color: 0x4a2c10 });

    function buildGraph() {
        nodes = []; adj = {};
        for (let r = 0; r < 5; r++)
            for (let c = 0; c < 9; c++)
                addNode(r*9+c, startX + c*stepX, startY + r*stepY);

        drawnMainLinks.forEach(l => addPath(l[0], l[1]));

        // Node dots + invisible hit targets
        Object.values(nodes).forEach(n => {
            const pos = nodePos3D(n.id);

            const dot = new THREE.Mesh(nodeDotGeo, nodeDotMat);
            dot.position.set(pos.x, SURF_Y + 0.022, pos.z);
            dot.receiveShadow = true;
            scene.add(dot);

            const hit = new THREE.Mesh(hitCircleGeo, hitCircleMat.clone());
            hit.position.set(pos.x, SURF_Y + 0.06, pos.z);
            hit.userData.nodeId = n.id;
            scene.add(hit);
            nodeHitMeshes.push(hit);
        });

        // Connection lines
        const seen = new Set();
        Object.values(nodes).forEach(n => {
            adj[n.id].forEach(toId => {
                const key = n.id < toId ? `${n.id}-${toId}` : `${toId}-${n.id}`;
                if (seen.has(key)) return;
                seen.add(key);
                const p1 = nodePos3D(n.id).clone();
                const p2 = nodePos3D(toId).clone();
                p1.y = p2.y = SURF_Y + 0.012;
                const geo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
                scene.add(new THREE.Line(geo, lineMat));
            });
        });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  STONE MESHES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const stoneGeo = new THREE.SphereGeometry(STONE_R, 40, 40);

    // Material factory â€” clone each time so emissiveIntensity can be animated independently
    function makeStoneMat(color, selected) {
        return new THREE.MeshStandardMaterial(color === 'red'
            ? { color: 0xe53935, roughness: 0.20, metalness: 0.20,
                emissive: selected ? 0xff5533 : 0x8e0000,
                emissiveIntensity: selected ? 0.55 : 0.08 }
            : { color: 0x4caf50, roughness: 0.20, metalness: 0.20,
                emissive: selected ? 0x44ff44 : 0x1b5e20,
                emissiveIntensity: selected ? 0.55 : 0.08 }
        );
    }

    const hintGeo = new THREE.CylinderGeometry(0.26, 0.26, 0.045, 20);
    const hintMat = new THREE.MeshStandardMaterial({
        color: 0xffffff, transparent: true, opacity: 0.5,
        emissive: 0xffffff, emissiveIntensity: 0.35
    });

    let stoneMeshes  = {};   // nodeId â†’ Mesh
    let hintMeshObjs = [];   // array of hint Meshes

    function renderBoard() {
        // Clear existing stones
        Object.values(stoneMeshes).forEach(m => { if (m) scene.remove(m); });
        stoneMeshes = {};

        // Clear hints
        hintMeshObjs.forEach(m => scene.remove(m));
        hintMeshObjs = [];

        const validMoves = state.selected !== null
            ? getMoves(state.selected, state.isCombo)
            : [];

        Object.values(nodes).forEach(n => {
            const pos = nodePos3D(n.id);

            // Stone
            if (state.board[n.id]) {
                const color = state.board[n.id];
                const isSel = state.selected === n.id;
                const mesh = new THREE.Mesh(stoneGeo, makeStoneMat(color, isSel));
                mesh.position.set(pos.x, SURF_Y + STONE_R + (isSel ? 0.10 : 0), pos.z);
                mesh.castShadow = true;
                if (isSel) mesh.scale.setScalar(1.09);
                scene.add(mesh);
                stoneMeshes[n.id] = mesh;
            }

            // Hint disc
            if (validMoves.some(m => m.to === n.id)) {
                const hint = new THREE.Mesh(hintGeo, hintMat.clone());
                hint.position.set(pos.x, SURF_Y + 0.025, pos.z);
                scene.add(hint);
                hintMeshObjs.push(hint);
            }
        });
    }

    // Bobbing + pulse animation for selected stone & hints
    let animClock = 0;
    function animateStones(dt) {
        animClock += dt * 0.0028;

        const selMesh = stoneMeshes[state.selected];
        if (selMesh) {
            const bob = Math.sin(animClock * 2.2) * 0.045;
            const base = nodePos3D(state.selected);
            selMesh.position.y = SURF_Y + STONE_R + 0.10 + bob;
            selMesh.material.emissiveIntensity = 0.38 + Math.sin(animClock * 2.8) * 0.24;
        }

        const hintPulse = 0.30 + Math.sin(animClock * 3.2) * 0.20;
        hintMeshObjs.forEach(h => { h.material.opacity = hintPulse; });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  RAYCASTING / POINTER CLICK
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let pointerDownPos = null;
    const DRAG_THRESHOLD = 8; // pixels

    renderer.domElement.addEventListener('pointerdown', e => {
        pointerDownPos = { x: e.clientX, y: e.clientY };
    });
    renderer.domElement.addEventListener('pointerup', e => {
        if (!pointerDownPos) return;
        const dx = e.clientX - pointerDownPos.x;
        const dy = e.clientY - pointerDownPos.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        pointerDownPos = null;
        if (dist > DRAG_THRESHOLD) return;  // real drag â†’ orbit
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x =  ((e.clientX - rect.left) / rect.width)  * 2 - 1;
        mouse.y = -((e.clientY - rect.top)  / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(nodeHitMeshes, false);
        if (hits.length > 0) handleNodeClick(hits[0].object.userData.nodeId);
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  GAME LOGIC  (identical to the 2-D version)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function getMoves(id, onlyCaps = false) {
        const list = [];
        const color = state.board[id];
        const enemy = color === 'red' ? 'green' : 'red';
        if (!adj[id]) return list;
        adj[id].forEach(to => {
            if (!state.board[to] && !onlyCaps) {
                list.push({ to, cap: null });
            } else if (state.board[to] === enemy) {
                const n1 = nodes[id], n2 = nodes[to];
                const tx = n2.x + (n2.x - n1.x), ty = n2.y + (n2.y - n1.y);
                const land = Object.values(nodes).find(x => Math.abs(x.x - tx) < 5 && Math.abs(x.y - ty) < 5);
                if (land && !state.board[land.id] && adj[to].includes(land.id))
                    list.push({ to: land.id, cap: to });
            }
        });
        return list;
    }

    function handleNodeClick(id) {
        if (state.gameOver || (state.mode === 'pve' && state.turn === 'green')) return;
        if (state.isCombo) {
            if (id === state.selected) { finishTurn(); return; }
            const move = getMoves(state.selected, true).find(m => m.to === id);
            if (move) performMove(state.selected, id, move.cap);
            return;
        }
        if (state.board[id] === state.turn) state.selected = id;
        else if (state.selected !== null && !state.board[id]) {
            const move = getMoves(state.selected).find(m => m.to === id);
            if (move) performMove(state.selected, id, move.cap);
        }
        renderBoard();
    }

    function performMove(from, to, capId) {
        state.board[to] = state.board[from]; state.board[from] = null;
        if (capId) {
            state.board[capId] = null;
            state.turn === 'red' ? state.score.green-- : state.score.red--;
            playSfx('capture');
            const nextCaps = getMoves(to, true);
            if (nextCaps.length > 0) {
                state.isCombo = true; state.selected = to;
                renderBoard(); updateUI();
                if (state.mode === 'pve' && state.turn === 'green') setTimeout(aiPlay, 1400);
                return;
            }
        } else { playSfx('move'); }
        finishTurn();
    }

    function finishTurn() {
        checkWinner(); if (state.gameOver) return;
        state.isCombo = false; state.selected = null;
        state.turn = state.turn === 'red' ? 'green' : 'red';
        renderBoard(); updateUI();
        if (state.mode === 'pve' && state.turn === 'green') setTimeout(aiPlay, 1300);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  AI  (minimax + alpha-beta, depth 5 for Hard â€” identical to 2-D)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function aiPlay() {
        if (state.gameOver) return;
        const rnd = arr => arr[Math.floor(Math.random() * arr.length)];

        function movesOnB(b, id) {
            const list = [], col = b[id]; if (!col) return list;
            const enemy = col === 'red' ? 'green' : 'red';
            if (!adj[id]) return list;
            adj[id].forEach(to => {
                if (!b[to]) list.push({ from: id, to, cap: null });
                else if (b[to] === enemy) {
                    const n1 = nodes[id], n2 = nodes[to];
                    const tx = n2.x+(n2.x-n1.x), ty = n2.y+(n2.y-n1.y);
                    const land = Object.values(nodes).find(x => Math.abs(x.x-tx)<5 && Math.abs(x.y-ty)<5);
                    if (land && !b[land.id] && adj[to].includes(land.id))
                        list.push({ from: id, to: land.id, cap: to });
                }
            });
            return list;
        }
        function allMoves(b, col) {
            const list = [];
            for (const id in b) if (b[id] === col) movesOnB(b, +id).forEach(m => list.push(m));
            return list;
        }
        function applyMv(b, fr, to, cap) {
            const nb = Object.assign({}, b); nb[to] = nb[fr]; nb[fr] = null;
            if (cap != null) nb[cap] = null; return nb;
        }
        function cnt(b, col) { let n=0; for (const k in b) if (b[k]===col) n++; return n; }
        function risk(b, col) {
            const enemy = col==='red'?'green':'red';
            return new Set(allMoves(b, enemy).filter(m=>m.cap).map(m=>m.cap)).size;
        }
        function eval_(b) {
            const g=cnt(b,'green'), r=cnt(b,'red');
            if (r===0) return 9999; if (g===0) return -9999;
            let s = (g-r)*100;
            s -= risk(b,'green')*35; s += risk(b,'red')*35;
            s += allMoves(b,'green').length*2; s -= allMoves(b,'red').length*2;
            return s;
        }
        function mm(b, d, a, be, max, combo) {
            const g=cnt(b,'green'), r=cnt(b,'red');
            if (r===0) return 9999+d*5; if (g===0) return-(9999+d*5);
            if (d===0) return eval_(b);
            let moves;
            if (combo!=null) {
                moves = movesOnB(b, combo).filter(m=>m.cap);
                if (!moves.length) return mm(b, d-1, a, be, !max, null);
            } else {
                const col = max?'green':'red';
                moves = allMoves(b, col);
                if (!moves.length) return max?-9999:9999;
                moves.sort((x,y)=>(y.cap!=null?1:0)-(x.cap!=null?1:0));
            }
            if (max) {
                let best=-Infinity;
                for (const m of moves) {
                    const nb=applyMv(b,m.from,m.to,m.cap);
                    const nc=(m.cap&&movesOnB(nb,m.to).some(x=>x.cap))?m.to:null;
                    const v=mm(nb,d-1,a,be,nc!=null,nc);
                    if(v>best) best=v; a=Math.max(a,v); if(be<=a) break;
                }
                return best;
            } else {
                let best=Infinity;
                for (const m of moves) {
                    const nb=applyMv(b,m.from,m.to,m.cap);
                    const nc=(m.cap&&movesOnB(nb,m.to).some(x=>x.cap))?m.to:null;
                    const v=mm(nb,d-1,a,be,nc?false:true,nc);
                    if(v<best) best=v; be=Math.min(be,v); if(be<=a) break;
                }
                return best;
            }
        }

        const board = Object.assign({}, state.board);

        /* EASY */
        if (state.aiLevel === 'easy') {
            if (state.isCombo) {
                const caps = getMoves(state.selected, true);
                if (caps.length) performMove(state.selected, caps[0].to, caps[0].cap); else finishTurn();
                return;
            }
            const all = allMoves(board, 'green');
            if (!all.length) { checkWinner(true); return; }
            const m = rnd(all); performMove(m.from, m.to, m.cap); return;
        }

        /* MEDIUM */
        if (state.aiLevel === 'medium') {
            if (state.isCombo) {
                const caps = getMoves(state.selected, true);
                if (caps.length) {
                    const sc = caps.map(m => {
                        const nb = applyMv(board, state.selected, m.to, m.cap);
                        return { m, s: cnt(nb,'green')-cnt(nb,'red')-risk(nb,'green')*0.3 };
                    });
                    sc.sort((a,b)=>b.s-a.s);
                    performMove(state.selected, sc[0].m.to, sc[0].m.cap);
                } else finishTurn();
                return;
            }
            const all = allMoves(board, 'green');
            if (!all.length) { checkWinner(true); return; }
            const caps = all.filter(m=>m.cap), pool = caps.length?caps:all;
            const hist = state.aiMoveHistory;
            const scored = pool.map(m => {
                const nb = applyMv(board, m.from, m.to, m.cap);
                let s = (cnt(nb,'green')-cnt(nb,'red'))*10 - risk(nb,'green')*4;
                s -= hist.filter(k=>k===`${m.from}-${m.to}`).length * 200;
                return { m, score: s };
            });
            scored.sort((a,b)=>b.score-a.score);
            const best = scored[0].m;
            state.aiMoveHistory.push(`${best.from}-${best.to}`);
            if (state.aiMoveHistory.length > 8) state.aiMoveHistory.shift();
            performMove(best.from, best.to, best.cap); return;
        }

        /* HARD */
        if (state.isCombo) {
            const caps = getMoves(state.selected, true);
            if (!caps.length) { finishTurn(); return; }
            let best=null, bs=-Infinity;
            for (const m of caps) {
                const nb = applyMv(board, state.selected, m.to, m.cap);
                const sc = mm(nb, 4, -Infinity, Infinity, false, null);
                if (sc>bs) { bs=sc; best=m; }
            }
            performMove(state.selected, best.to, best.cap); return;
        }
        const all = allMoves(board, 'green');
        if (!all.length) { checkWinner(true); return; }
        const ordered = [...all.filter(m=>m.cap), ...all.filter(m=>!m.cap)];
        const hist = state.aiMoveHistory;
        let best=null, bs=-Infinity;
        for (const m of ordered) {
            const nb = applyMv(board, m.from, m.to, m.cap);
            const nc = (m.cap && movesOnB(nb,m.to).some(x=>x.cap)) ? m.to : null;
            let sc = mm(nb, 5, -Infinity, Infinity, false, nc);
            sc -= hist.filter(k=>k===`${m.from}-${m.to}`).length * 250;
            if (sc>bs) { bs=sc; best=m; }
        }
        state.aiMoveHistory.push(`${best.from}-${best.to}`);
        if (state.aiMoveHistory.length > 8) state.aiMoveHistory.shift();
        performMove(best.from, best.to, best.cap);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  UI
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function updateUI() {
        const t  = document.getElementById('turn-txt');
        const s  = document.getElementById('status');
        const sc = document.getElementById('score');
        const cm = document.getElementById('combo-msg');
        if (!t||!s||!sc||!cm) return;
        t.innerText = state.turn==='red' ? 'KÄ±rmÄ±zÄ±' : (state.mode==='pvp'?'YeÅŸil':'Bilgisayar');
        s.style.background = state.turn==='red' ? '#e53935' : '#4caf50';
        s.style.color = 'white';
        sc.innerText = `KÄ±rmÄ±zÄ±: ${state.score.red} | YeÅŸil: ${state.score.green}`;
        cm.style.display = state.isCombo ? 'block' : 'none';
        const ts = document.getElementById('turn-stone');
        if (ts) ts.className = 'turn-stone-dot ' + state.turn;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  WINNER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function checkWinner(aiStuck = false) {
        let winColor = null;
        if (state.score.green === 0 || aiStuck) winColor = 'red';
        else if (state.score.red === 0) winColor = 'green';
        if (!winColor) return;
        state.gameOver = true;
        let headline, sub, cssClass, doFw = false;
        if (state.mode === 'pve') {
            if (winColor === 'red') { headline='ğŸ† KAZANDINIZ!'; sub='Tebrikler! BilgisayarÄ± yendiniz.'; cssClass='red-win'; doFw=true; setTimeout(()=>playSfx('applause'),600); }
            else                   { headline='ğŸ¤– BÄ°LGÄ°SAYAR KAZANDI'; sub='Bu sefer bilgisayar daha iyiydi.'; cssClass='ai-win'; }
        } else {
            if (winColor === 'red') { headline='ğŸ”´ KIRMIZI KAZANDI!'; sub='KÄ±rmÄ±zÄ± oyuncuyu tebrik ederiz!'; cssClass='red-win'; }
            else                    { headline='ğŸŸ¢ YEÅÄ°L KAZANDI!';   sub='YeÅŸil oyuncuyu tebrik ederiz!';   cssClass='green-win'; }
            doFw = true;
        }
        showWinnerModal(headline, sub, cssClass, doFw);
    }

    function showWinnerModal(headline, sub, cssClass, doFw) {
        const title  = document.getElementById('winner-title');
        const subEl  = document.getElementById('winner-sub');
        const trophy = document.getElementById('winner-trophy');
        if (title)  { title.innerText = headline; title.className = 'winner-headline '+cssClass; }
        if (subEl)  subEl.innerText = sub;
        if (trophy) trophy.innerText = cssClass==='ai-win' ? 'ğŸ¤–' : 'ğŸ†';
        document.getElementById('winner-modal').classList.add('show');
        playSfx('win');
        if (doFw) startFireworks();
    }

    function hideWinnerModal() {
        document.getElementById('winner-modal').classList.remove('show');
        stopFireworks();
    }

    function closeWinnerAndGoIntro() { hideWinnerModal(); openIntroScreen(); }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  FIREWORKS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let fwAnimId = null;

    function startFireworks() {
        const canvas = document.getElementById('fw-canvas'); if (!canvas) return;
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        canvas.style.display = 'block';
        const ctx = canvas.getContext('2d'), particles = [];
        const COLORS = ['#ff4444','#ff9900','#ffee00','#44ff44','#44aaff','#cc44ff','#ff44cc','#ffffff','#ff6680','#00ffcc'];

        function burst(x, y) {
            const n = 90 + Math.random()*60;
            for (let i=0; i<n; i++) {
                const a=(Math.PI*2/n)*i + Math.random()*0.3, sp=3+Math.random()*9;
                particles.push({ x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,alpha:1,
                    color:COLORS[Math.floor(Math.random()*COLORS.length)],
                    size:2+Math.random()*4, decay:0.012+Math.random()*0.012,
                    gravity:0.12+Math.random()*0.08, trail:[] });
            }
        }
        burst(canvas.width*0.50, canvas.height*0.35);
        burst(canvas.width*0.25, canvas.height*0.45);
        burst(canvas.width*0.75, canvas.height*0.40);

        let elapsed=0, idx=0, last=null;
        const times = Array.from({length:32}, (_,i) => 300+i*280+Math.random()*180);

        function frame(ts) {
            if (!last) last=ts;
            elapsed += ts-last; last=ts;
            while (idx<times.length && elapsed>=times[idx]) {
                burst(canvas.width*(0.12+Math.random()*0.76), canvas.height*(0.08+Math.random()*0.52));
                idx++;
            }
            ctx.fillStyle='rgba(0,0,0,0.17)'; ctx.fillRect(0,0,canvas.width,canvas.height);
            for (let i=particles.length-1; i>=0; i--) {
                const p=particles[i];
                p.trail.push({x:p.x,y:p.y,alpha:p.alpha});
                if (p.trail.length>7) p.trail.shift();
                for (const t of p.trail) {
                    ctx.beginPath(); ctx.arc(t.x,t.y,p.size*0.45,0,Math.PI*2);
                    ctx.fillStyle=p.color+Math.floor(t.alpha*70).toString(16).padStart(2,'0'); ctx.fill();
                }
                ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2);
                ctx.fillStyle=p.color+Math.floor(p.alpha*255).toString(16).padStart(2,'0'); ctx.fill();
                p.x+=p.vx; p.y+=p.vy; p.vy+=p.gravity; p.vx*=0.98; p.alpha-=p.decay;
                if (p.alpha<=0) particles.splice(i,1);
            }
            if (elapsed<10000||particles.length>0) fwAnimId=requestAnimationFrame(frame); else stopFireworks();
        }
        fwAnimId = requestAnimationFrame(frame);
    }

    function stopFireworks() {
        if (fwAnimId) { cancelAnimationFrame(fwAnimId); fwAnimId=null; }
        const c = document.getElementById('fw-canvas');
        if (c) { c.style.display='none'; c.getContext('2d').clearRect(0,0,c.width,c.height); }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  INTRO / THEME / ORIENTATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function selectIntroMode(mode) {
        introMode = mode;
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.toggle('active', b.dataset.mode===mode));
        const wrap = document.getElementById('intro-diff-wrap');
        if (wrap) wrap.style.display = mode==='pve' ? 'block' : 'none';
    }

    function selectIntroDiff(level) {
        introDiff = level;
        document.querySelectorAll('.diff-btn').forEach(b => b.classList.toggle('active', b.dataset.level===level));
    }

    function openIntroScreen() {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.toggle('active', b.dataset.mode===introMode));
        document.querySelectorAll('.diff-btn').forEach(b => b.classList.toggle('active', b.dataset.level===introDiff));
        const wrap = document.getElementById('intro-diff-wrap');
        if (wrap) wrap.style.display = introMode==='pve' ? 'block' : 'none';
        document.getElementById('howto-screen').style.display = 'flex';
        switchToBgm('intro');
    }

    function closeHowToScreen() {
        document.getElementById('howto-screen').style.display = 'none';
        hideWinnerModal();
        switchToBgm('game');
        userMovedCamera = false;
        setCameraDefault();
        initGame();
    }

    function openHowtoModal()   { document.getElementById('howto-modal-bg').classList.add('show'); }
    function closeHowtoModal(e) {
        if (!e || e.target === document.getElementById('howto-modal-bg'))
            document.getElementById('howto-modal-bg').classList.remove('show');
    }

    function toggleTheme() {
        const body = document.body, btn = document.getElementById('themeBtn');
        const next = (body.getAttribute('data-theme')||'dark')==='dark' ? 'light' : 'dark';
        body.setAttribute('data-theme', next);
        if (btn) btn.innerText = next==='dark' ? 'â˜€ï¸ GÃœNDÃœZ MODU' : 'ğŸŒ™ GECE MODU';
        // Adjust scene background
        scene.background = new THREE.Color(next==='dark' ? 0x0c0809 : 0x2a1e14);
    }

    function checkOrientation() {
        const isMobile = window.matchMedia('(max-width:900px)').matches;
        const isLandscape = window.innerWidth > window.innerHeight;
        const lock = document.getElementById('landscape-lock');
        if (isMobile && isLandscape) lock.classList.add('show'); else lock.classList.remove('show');
    }

    window.addEventListener('resize', () => {
        camera.aspect = canvasArea.clientWidth / canvasArea.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(canvasArea.clientWidth, canvasArea.clientHeight);
        if (!userMovedCamera) setCameraDefault();
        checkOrientation();
    });
    window.addEventListener('orientationchange', checkOrientation);
    checkOrientation();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  INIT GAME
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function initGame() {
        state.board = {}; state.gameOver = false; state.turn = 'red';
        state.selected = null; state.isCombo = false;
        state.score = { red: 18, green: 18 };
        state.mode = introMode; state.aiLevel = introDiff;
        state.aiMoveHistory = [];
        hideWinnerModal();

        const greenNodes = [8,26,44,16,25,34,24,6,15,33,42,5,14,23,32,41,4,13];
        const redNodes   = [0,18,36,10,19,28,20,2,11,29,38,3,12,21,30,39,31,40];
        greenNodes.forEach(id => state.board[id] = 'green');
        redNodes.forEach(id   => state.board[id] = 'red');
        state.score.red   = Object.values(state.board).filter(v=>v==='red').length;
        state.score.green = Object.values(state.board).filter(v=>v==='green').length;

        renderBoard();
        updateUI();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  STAR FIELD
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let stars;
    function createStarField() {
        const geometry = new THREE.BufferGeometry();
        const count = 2500;
        const positions = new Float32Array(count * 3);
        const colors    = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
            const r     = 25 + Math.random() * 45;
            const theta = Math.random() * Math.PI * 2;
            const phi   = Math.acos(2 * Math.random() - 1);
            positions[i*3]   = r * Math.sin(phi) * Math.cos(theta);
            positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i*3+2] = r * Math.cos(phi);
            const t = Math.random();
            if      (t > 0.9) { colors[i*3]=1.0; colors[i*3+1]=0.8; colors[i*3+2]=0.4; } // warm gold
            else if (t > 0.7) { colors[i*3]=0.4; colors[i*3+1]=0.8; colors[i*3+2]=1.0; } // cool blue
            else if (t > 0.5) { colors[i*3]=0.8; colors[i*3+1]=0.4; colors[i*3+2]=1.0; } // violet
            else              { colors[i*3]=1.0; colors[i*3+1]=1.0; colors[i*3+2]=1.0; } // white
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color',    new THREE.BufferAttribute(colors, 3));
        const material = new THREE.PointsMaterial({
            size: 0.18, vertexColors: true,
            transparent: true, opacity: 0.88,
            sizeAttenuation: true, depthWrite: false
        });
        stars = new THREE.Points(geometry, material);
        scene.add(stars);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  RENDER LOOP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let prevNow = performance.now();
    function animate(now) {
        requestAnimationFrame(animate);
        const dt = now - prevNow; prevNow = now;
        controls.update();
        animateStones(dt);
        if (stars) {
            stars.position.copy(camera.position);
            stars.rotation.y += 0.00035;
            stars.rotation.x += 0.00012;
        }
        renderer.render(scene, camera);
    }
    requestAnimationFrame(animate);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  EXPOSE TO HTML onclick HANDLERS  (module scope â†’ global)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    window.closeHowToScreen     = closeHowToScreen;
    window.closeWinnerAndGoIntro = closeWinnerAndGoIntro;
    window.selectIntroMode      = selectIntroMode;
    window.selectIntroDiff      = selectIntroDiff;
    window.openIntroScreen      = openIntroScreen;
    window.openHowtoModal       = openHowtoModal;
    window.closeHowtoModal      = closeHowtoModal;
    window.toggleMusic          = toggleMusic;
    window.toggleTheme          = toggleTheme;

    // â”€â”€ Mobile sidebar toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function toggleSidebar() {
        const sb  = document.getElementById('sidebar');
        const btn = document.getElementById('menu-toggle-btn');
        const isOpen = sb.classList.toggle('open');
        btn.textContent = isOpen ? 'â–¼ KAPAT' : 'â–² MENÃœ';
    }
    window.toggleSidebar = toggleSidebar;
    window.resetCamera   = () => { userMovedCamera = false; setCameraDefault(); };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  STARTUP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    document.body.setAttribute('data-theme', 'dark');
    buildGraph();
    setupAudio();
    createStarField();
    // initGame() is called by closeHowToScreen() when user presses OYUNA BAÅLA

</script>
<script src="bg-animation.js"></script>
</body>
</html>
