<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Polytop Restorasyonu - Canlƒ± Y√ºzeyler</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Orbitron', sans-serif; touch-action: none; }
        
        #main-menu { position: fixed; inset: 0; background: radial-gradient(circle, #0f172a 0%, #000 100%); z-index: 1000; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .menu-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; margin-top: 20px; }
        .menu-item { width: 60px; height: 60px; background: rgba(56, 189, 248, 0.1); border: 1px solid #38bdf8; color: #38bdf8; display: flex; align-items: center; justify-content: center; border-radius: 10px; cursor: pointer; font-weight: bold; transition: 0.3s; }
        .menu-item:hover { background: #38bdf8; color: #000; box-shadow: 0 0 20px #38bdf8; }

        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 20px; box-sizing: border-box; display: none; flex-direction: column; justify-content: space-between; z-index: 100; }
        .panel { background: rgba(10, 20, 40, 0.9); border: 2px solid #38bdf8; padding: 12px; border-radius: 15px; color: #38bdf8; pointer-events: auto; }
        .btn { background: #38bdf8; border: none; color: #000; padding: 10px 20px; border-radius: 30px; cursor: pointer; font-weight: bold; pointer-events: auto; text-transform: uppercase; transition: 0.3s; }
        
        #collision-lock { position: fixed; inset: 0; background: rgba(150, 0, 0, 0.7); backdrop-filter: blur(10px); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 5000; pointer-events: auto; }
        #win-screen { position: absolute; inset: 0; display: none; flex-direction: column; justify-content: flex-end; align-items: center; padding-bottom: 60px; z-index: 200; pointer-events: none; }
        .win-content { background: rgba(0,0,0,0.9); padding: 25px; border-radius: 20px; border: 2px solid #4ade80; pointer-events: auto; text-align: center; }
    </style>
</head>
<body>

    <div id="main-menu">
        <h1 style="color:#38bdf8; text-shadow: 0 0 15px #38bdf8; text-align: center; font-size: 1.8rem;">POLYTOP RESTORASYONU</h1>
        <div class="menu-grid" id="menu-grid"></div>
    </div>

    <div id="ui">
        <div class="panel" style="width: fit-content;">
            <h2 id="target-name" style="margin:0; font-size:0.85rem;">-</h2>
            <div style="font-size: 0.65rem; color: #94a3b8; margin-top:5px;">üîµ Bo≈üta | üü° Yerle≈üti | üü¢ Neon Sil√ºet</div>
        </div>
        <button class="btn" onclick="game.showMenu()">ANA MEN√ú üè†</button>
    </div>

    <div id="collision-lock">
        <div style="background:#000; padding:30px; border-radius:20px; border:3px solid #f00; text-align:center;">
            <h2 style="color:#f00; margin:0 0 10px 0;">üõë √áAKI≈ûMA!</h2>
            <button class="btn" style="background:#f00; color:#fff;" onclick="game.restoreSafeState()">GERƒ∞ AL</button>
        </div>
    </div>

    <div id="win-screen">
        <div class="win-content">
            <h2 style="color:#4ade80; margin:0;">TAMAMLANDI!</h2>
            <div id="win-timer" style="color:#fff; margin: 8px 0; font-size: 0.8rem;">Analiz ediliyor...</div>
            <button id="next-btn" class="btn" style="display:none; background:#4ade80;" onclick="game.nextLevel()">SIRADAKƒ∞ ‚ñ∂</button>
        </div>
    </div>

    <script>
        const PHI = (1 + Math.sqrt(5)) / 2;
        const COLORS = { normal: 0x38bdf8, snapped: 0xfacc15, target: 0x00ff88, danger: 0xff0000, safe: 0x4ade80, surface: 0x00ff88 };

        const POLYTOPES = [
            { name: "1. D√∂rty√ºzl√º (Tetrahedron)", nodes: [[1,1,1], [1,-1,-1], [-1,1,-1], [-1,-1,1]], edges: [[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]], faces: [[0,1,2],[0,2,3],[0,3,1],[1,3,2]], scale: 28 },
            { name: "2. K√ºp (Hexahedron)", nodes: [[1,1,1], [1,1,-1], [1,-1,1], [1,-1,-1], [-1,1,1], [-1,1,-1], [-1,-1,1], [-1,-1,-1]], edges: [[0,1],[0,2],[0,4],[1,3],[1,5],[2,3],[2,6],[3,7],[4,5],[4,6],[5,7],[6,7]], faces: [[0,2,3],[0,3,1],[4,5,7],[4,7,6],[0,1,5],[0,5,4],[2,6,7],[2,7,3],[0,4,6],[0,6,2],[1,3,7],[1,7,5]], scale: 22 },
            { name: "3. Sekizy√ºzl√º (Octahedron)", nodes: [[1,0,0], [-1,0,0], [0,1,0], [0,-1,0], [0,0,1], [0,0,-1]], edges: [[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]], faces: [[0,2,4],[0,4,3],[0,3,5],[0,5,2],[1,2,5],[1,5,3],[1,3,4],[1,4,2]], scale: 30 },
            { name: "4. Kare Piramit", nodes: [[0,0,1.4], [1,1,0], [1,-1,0], [-1,1,0], [-1,-1,0]], edges: [[0,1],[0,2],[0,3],[0,4],[1,2],[2,4],[4,3],[3,1]], faces: [[0,1,2],[0,2,4],[0,4,3],[0,3,1],[1,2,3,4]], scale: 30 },
            { name: "5. √ú√ßgen Prizma", nodes: [[1,0,1], [-0.5,0.86,1], [-0.5,-0.86,1], [1,0,-1], [-0.5,0.86,-1], [-0.5,-0.86,-1]], edges: [[0,1],[1,2],[2,0],[3,4],[4,5],[5,3],[0,3],[1,4],[2,5]], faces: [[0,1,2],[3,5,4],[0,3,4,1],[1,4,5,2],[2,5,3,0]], scale: 28 },
            { name: "6. Be≈ügen Piramit", nodes: (()=>{let v=[[0,0,1.5]]; for(let i=0; i<5; i++){let a=(i/5)*Math.PI*2; v.push([Math.cos(a),Math.sin(a),0])} return v})(), edges: [[0,1],[0,2],[0,3],[0,4],[0,5],[1,2],[2,3],[3,4],[4,5],[5,1]], faces: [[0,1,2],[0,2,3],[0,3,4],[0,4,5],[0,5,1],[1,2,3,4,5]], scale: 32 },
            { name: "7. Altƒ±gen Prizma", nodes: (()=>{let v=[]; for(let i=0; i<6; i++){let a=(i/6)*Math.PI*2; v.push([Math.cos(a),Math.sin(a),1],[Math.cos(a),Math.sin(a),-1])} return v})(), autoEdge: 1.2, scale: 28 },
            { name: "8. K√ºpoktay√ºz", nodes: (()=>{let v=[]; for(let i of [-1,1])for(let j of [-1,1]) v.push([i,j,0],[i,0,j],[0,i,j]); return v})(), autoEdge: 1.5, scale: 28 },
            { name: "9. Onikiy√ºzl√º", nodes: (()=>{let v=[]; for(let x of [-1,1])for(let y of [-1,1])for(let z of [-1,1]) v.push([x,y,z]); for(let i of [-1,1]){v.push([0,i*PHI,i/PHI],[0,i*PHI,-i/PHI],[i/PHI,0,i*PHI],[-i/PHI,0,i*PHI],[i/PHI,i/PHI,0],[i*PHI,-i/PHI,0])} return v})(), autoEdge: 1.25, scale: 20 },
            { name: "10. Yirmiy√ºzl√º", nodes: (()=>{let v=[]; for(let i of [-1,1]){v.push([0,i,i*PHI],[0,i,-i*PHI],[i,i*PHI,0],[i,-i*PHI,0],[i*PHI,0,i],[i*PHI,0,-i])} return v})(), autoEdge: 1.25, scale: 22 }
        ];

        class Game {
            constructor() {
                this.currentLevel = 0; this.nodes = []; this.edges = []; this.targetPoints = []; this.isSolved = false;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
                this.camera.position.set(0, 50, 110);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                document.body.appendChild(this.renderer.domElement);

                this.scene.add(new THREE.AmbientLight(0xffffff, 0.5));
                const sun = new THREE.DirectionalLight(0xffffff, 0.8); sun.position.set(50, 80, 50); this.scene.add(sun);

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE }; // Sol tƒ±k normalde d√∂nd√ºr√ºr

                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.dragPlane = new THREE.Plane();
                this.pIntersect = new THREE.Vector3();
                this.draggedNode = null;

                window.addEventListener('pointerdown', e => this.onPointerDown(e));
                window.addEventListener('pointermove', e => this.onPointerMove(e));
                window.addEventListener('pointerup', () => this.onPointerUp());
                window.addEventListener('resize', () => this.onResize());

                this.initMenu();
                this.animate();
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            initMenu() {
                const grid = document.getElementById('menu-grid'); grid.innerHTML = '';
                POLYTOPES.forEach((p, i) => {
                    const item = document.createElement('div');
                    item.className = 'menu-item'; item.innerText = i + 1;
                    item.onclick = () => { this.currentLevel = i; this.startLevel(); };
                    grid.appendChild(item);
                });
            }

            showMenu() { document.getElementById('main-menu').style.display = 'flex'; document.getElementById('ui').style.display = 'none'; }

            startLevel() {
                document.getElementById('main-menu').style.display = 'none';
                document.getElementById('ui').style.display = 'flex';
                document.getElementById('win-screen').style.display = 'none';
                document.getElementById('next-btn').style.display = 'none';
                
                while(this.scene.children.length > 2) this.scene.remove(this.scene.children[this.scene.children.length-1]);
                this.nodes = []; this.edges = []; this.targetPoints = []; this.isSolved = false;

                const data = POLYTOPES[this.currentLevel % POLYTOPES.length];
                document.getElementById('target-name').innerText = data.name;

                // 1. Hedefler ve Canlƒ± Sil√ºet
                data.nodes.forEach((p, i) => {
                    const pos = new THREE.Vector3(p[0], p[1], p[2]).multiplyScalar(data.scale);
                    this.targetPoints.push({ pos });
                    
                    const mTarget = new THREE.Mesh(new THREE.SphereGeometry(3, 12, 12), new THREE.MeshBasicMaterial({ color: COLORS.target, transparent: true, opacity: 0.2 }));
                    mTarget.position.copy(pos); this.scene.add(mTarget);

                    const mNode = new THREE.Mesh(new THREE.SphereGeometry(5.5, 32, 32), new THREE.MeshStandardMaterial({ color: COLORS.normal, metalness: 0.8, roughness: 0.2 }));
                    mNode.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5)*25, (Math.random()-0.5)*25, (Math.random()-0.5)*25));
                    this.scene.add(mNode); this.nodes.push(mNode);
                });

                // 2. Halatlar
                let pairs = data.edges || [];
                if (data.autoEdge) {
                    pairs = [];
                    for(let i=0; i<this.nodes.length; i++) {
                        for(let j=i+1; j<this.nodes.length; j++) {
                            if (this.targetPoints[i].pos.distanceTo(this.targetPoints[j].pos) < data.scale * data.autoEdge + 1) pairs.push([i, j]);
                        }
                    }
                }

                pairs.forEach(p => {
                    const geo = new THREE.CylinderGeometry(1.5, 1.5, 1, 10);
                    geo.rotateX(Math.PI/2); geo.translate(0, 0, 0.5);
                    const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: COLORS.safe }));
                    this.scene.add(mesh);
                    this.edges.push({ mesh, n1: this.nodes[p[0]], n2: this.nodes[p[1]] });
                });

                // 3. Hayalet Y√ºzeyler (Canlƒ± Neon)
                if (data.faces) {
                    const geo = new THREE.BufferGeometry();
                    const indices = [];
                    data.faces.forEach(f => { for(let i=1; i<f.length-1; i++) indices.push(f[0], f[i], f[i+1]); });
                    geo.setFromPoints(this.targetPoints.map(t => t.pos)); geo.setIndex(indices); geo.computeVertexNormals();
                    this.surfaceMesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: COLORS.surface, transparent: true, opacity: 0.15, side: THREE.DoubleSide, emissive: COLORS.surface, emissiveIntensity: 0.2 }));
                    this.scene.add(this.surfaceMesh);
                }

                this.safeShuffle(200, 4.8);
                this.updateLines();
            }

            safeShuffle(steps, minDist) {
                for(let i=0; i<steps; i++) {
                    const node = this.nodes[Math.floor(Math.random() * this.nodes.length)];
                    const old = node.position.clone();
                    node.position.add(new THREE.Vector3((Math.random()-0.5)*30, (Math.random()-0.5)*30, (Math.random()-0.5)*30));
                    if(this.detectCollision(minDist)) node.position.copy(old);
                }
                this.nodes.forEach(n => { n.userData.snapped = false; n.material.color.setHex(COLORS.normal); });
            }

            onPointerDown(e) {
                if(this.isSolved) return;
                this.updateMouse(e);
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const hits = this.raycaster.intersectObjects(this.nodes);
                
                if(hits.length > 0) {
                    this.draggedNode = hits[0].object;
                    this.lastSafePos = this.nodes.map(n => n.position.clone());
                    this.controls.enabled = false; // S√ºr√ºklerken kamerayƒ± kilitle

                    // S√ºr√ºkleme d√ºzlemini kameraya paralel kur
                    const normal = new THREE.Vector3();
                    this.camera.getWorldDirection(normal);
                    this.dragPlane.setFromNormalAndCoplanarPoint(normal.negate(), this.draggedNode.position);
                }
            }

            onPointerMove(e) {
                if(!this.draggedNode || this.isSolved) return;
                this.updateMouse(e);
                this.raycaster.setFromCamera(this.mouse, this.camera);

                if(this.raycaster.ray.intersectPlane(this.dragPlane, this.pIntersect)) {
                    this.draggedNode.position.copy(this.pIntersect);
                    
                    // Serbest Snap (Herhangi bir k√∂≈üeye)
                    let snapped = false;
                    for(let tp of this.targetPoints) {
                        if(this.draggedNode.position.distanceTo(tp.pos) < 9) {
                            this.draggedNode.position.copy(tp.pos);
                            snapped = true; break;
                        }
                    }
                    this.draggedNode.userData.snapped = snapped;
                    this.draggedNode.material.color.setHex(snapped ? COLORS.snapped : COLORS.normal);
                    
                    this.updateLines();
                    if(this.detectCollision(2.6)) this.triggerCollisionLock();
                }
            }

            onPointerUp() {
                this.draggedNode = null;
                this.controls.enabled = true;
                
                let allFilled = this.targetPoints.every(tp => this.nodes.some(n => n.position.distanceTo(tp.pos) < 1));
                if(!this.isSolved && allFilled) this.complete();
            }

            updateMouse(e) {
                this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            }

            updateLines() { this.edges.forEach(e => { const d = e.n1.position.distanceTo(e.n2.position); e.mesh.position.copy(e.n1.position); e.mesh.scale.set(1, 1, d); e.mesh.lookAt(e.n2.position); }); }

            detectCollision(limit) {
                for(let i=0; i<this.edges.length; i++) {
                    for(let j=i+1; j<this.edges.length; j++) {
                        const e1 = this.edges[i], e2 = this.edges[j];
                        if(e1.n1===e2.n1 || e1.n1===e2.n2 || e1.n2===e2.n1 || e1.n2===e2.n2) continue;
                        if(this.getLineDist(e1.n1.position, e1.n2.position, e2.n1.position, e2.n2.position) < limit) return true;
                    }
                } return false;
            }

            triggerCollisionLock() { this.draggedNode = null; this.controls.enabled = false; document.getElementById('collision-lock').style.display = 'flex'; }
            restoreSafeState() {
                this.nodes.forEach((n, i) => { n.position.copy(this.lastSafePos[i]); n.material.color.setHex(COLORS.normal); n.userData.snapped = false; });
                this.controls.enabled = true; document.getElementById('collision-lock').style.display = 'none'; this.updateLines();
            }

            getLineDist(p1, p2, p3, p4) {
                const u = p2.clone().sub(p1), v = p4.clone().sub(p3), w = p1.clone().sub(p3);
                const a = u.dot(u), b = u.dot(v), c = v.dot(v), d = u.dot(w), e = v.dot(w);
                const D = a*c - b*b; let sc, tc;
                if (D < 0.001) { sc = 0; tc = b > c ? d/b : e/c; } else { sc = (b*e - c*d)/D; tc = (a*e - b*d)/D; }
                return p1.clone().add(u.multiplyScalar(Math.max(0,Math.min(1,sc)))).distanceTo(p3.clone().add(v.multiplyScalar(Math.max(0,Math.min(1,tc)))));
            }

            complete() {
                this.isSolved = true; document.getElementById('win-screen').style.display = 'flex';
                this.edges.forEach(e => e.mesh.material.color.setHex(0xffd700));
                if(this.surfaceMesh) {
                    let op = 0.15;
                    const fade = setInterval(() => { op += 0.05; this.surfaceMesh.material.opacity = op; if(op >= 0.85) clearInterval(fade); }, 50);
                }
                let timeLeft = 10;
                const timer = setInterval(() => { timeLeft--; document.getElementById('win-timer').innerText = `Analiz ediliyor... (${timeLeft}s)`; if(timeLeft <= 0) { clearInterval(timer); document.getElementById('next-btn').style.display = 'block'; } }, 1000);
            }

            nextLevel() { this.currentLevel++; this.startLevel(); }
            animate() { requestAnimationFrame(() => this.animate()); this.controls.update(); this.renderer.render(this.scene, this.camera); }
        }
        const game = new Game();
    </script>
</body>
</html>