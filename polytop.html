<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Polytop Restorasyonu - Topolojik D√ºƒü√ºm</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        :root { --neon: #38bdf8; --target: #4ade80; --danger: #ef4444; --gold: #facc15; }
        
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Orbitron', sans-serif; touch-action: none; }
        
        #top-bar { 
            position: fixed; top: 10px; left: 0; width: 100%; 
            display: flex; justify-content: space-between; align-items: center; 
            padding: 0 20px; box-sizing: border-box; z-index: 2000; pointer-events: none;
        }
        .ui-box { 
            background: rgba(15, 23, 42, 0.8); border: 1px solid var(--neon); 
            padding: 8px 15px; border-radius: 12px; color: var(--neon); 
            font-size: 0.8rem; pointer-events: auto; backdrop-filter: blur(5px);
        }
        .reward-badge { border-color: var(--gold); color: var(--gold); }

        #main-menu { position: fixed; inset: 0; background: radial-gradient(circle, #0f172a 0%, #000 100%); z-index: 3000; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; }
        .menu-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; margin-top: 20px; }
        .menu-item { 
            width: 60px; height: 60px; background: rgba(56, 189, 248, 0.1); border: 1px solid #38bdf8; 
            color: #38bdf8; display: flex; align-items: center; justify-content: center; 
            border-radius: 10px; cursor: pointer; font-weight: bold; transition: 0.3s; 
        }
        .menu-item.locked { opacity: 0.3; cursor: not-allowed; border-color: #444; color: #444; }
        .menu-item:not(.locked):hover { background: #38bdf8; color: #000; box-shadow: 0 0 20px #38bdf8; }

        #ui { position: absolute; top: 80px; left: 20px; width: 220px; pointer-events: none; z-index: 100; display: none; }
        .panel { background: rgba(10, 20, 40, 0.9); border: 2px solid var(--neon); padding: 12px; border-radius: 15px; color: var(--neon); pointer-events: auto; }
        .bar-bg { background: #000; height: 8px; border-radius: 4px; margin: 10px 0; border: 1px solid #1e293b; overflow: hidden; }
        #bar-fill { background: var(--target); height: 100%; width: 0%; transition: width 0.3s; }
        
        .btn { background: var(--neon); border: none; color: #000; padding: 10px 20px; border-radius: 30px; cursor: pointer; font-weight: bold; pointer-events: auto; text-transform: uppercase; transition: 0.3s; margin-top: 10px; }
        
        #collision-lock { position: fixed; inset: 0; background: rgba(150, 0, 0, 0.7); backdrop-filter: blur(10px); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 5000; }
        
        #win-screen { 
            position: fixed; inset: 0; background: radial-gradient(circle, transparent 0%, rgba(0,0,0,0.8) 100%); 
            display: none; flex-direction: column; justify-content: flex-end; align-items: center; 
            z-index: 6000; padding-bottom: 50px; pointer-events: none;
        }
        .win-content { background: rgba(0,0,0,0.9); border: 2px solid var(--target); padding: 30px; border-radius: 20px; pointer-events: auto; text-align: center; }

        .score-float { 
            position: absolute; color: var(--target); font-weight: 900; font-size: 24px; 
            pointer-events: none; z-index: 10000; text-shadow: 0 0 8px #000; 
            animation: floatUp 1s ease-out forwards;
        }
        @keyframes floatUp { 0% { transform: translateY(0); opacity: 0; } 20% { opacity: 1; } 100% { transform: translateY(-100px); opacity: 0; } }
    </style>
</head>
<body>

    <div id="top-bar">
        <div class="ui-box">TOPLAM: <span id="total-score">0</span></div>
        <div class="ui-box reward-badge">√ñD√úL: <span id="current-reward">100</span></div>
    </div>

    <div id="main-menu">
        <h1 style="color:#38bdf8; text-shadow: 0 0 15px #38bdf8; text-align: center; font-size: 1.8rem; margin: 0;">POLYTOP RESTORASYONU</h1>
        <p style="color: #64748b; font-size: 0.8rem; margin-bottom: 20px;">Topolojik d√ºƒü√ºm√º √ß√∂z√ºn ve formu restore edin.</p>
        <div class="menu-grid" id="menu-grid"></div>
        <button class="btn" style="margin-top: 40px; background: transparent; color: #444; border: 1px solid #444; font-size: 0.6rem;" onclick="game.resetData()">VERƒ∞LERƒ∞ SIFIRLA</button>
    </div>

    <div id="ui">
        <div class="panel">
            <div id="timer-display" style="font-size: 1.5rem; font-weight: bold; text-align: center;">00.0</div>
            <h2 id="target-name" style="margin:5px 0; font-size:0.75rem; text-align: center;">-</h2>
            <div class="bar-bg"><div id="bar-fill"></div></div>
            <div style="font-size: 0.6rem; text-align: center; color: #94a3b8;">UYUM: %<span id="percent-val">0</span></div>
            <button class="btn" style="width: 100%; font-size: 0.7rem;" onclick="game.showMenu()">ANA MEN√ú üè†</button>
        </div>
    </div>

    <div id="collision-lock">
        <div style="background:#000; padding:30px; border-radius:20px; border:3px solid #f00; text-align:center;">
            <h2 style="color:#f00; margin:0 0 10px 0;">üõë √áAKI≈ûMA!</h2>
            <p style="color:#fff; font-size:0.75rem; margin-bottom: 15px;">D√ºƒü√ºmler arasƒ± ge√ßi≈ü engellendi.</p>
            <button class="btn" style="background:#f00; color:#fff;" onclick="game.restoreSafeState()">GERƒ∞ AL</button>
        </div>
    </div>

    <div id="win-screen">
        <div class="win-content">
            <h1 style="color:var(--target); font-size: 2rem; margin: 0;">BA≈ûARILI!</h1>
            <div id="win-stats" style="color:#fff; margin: 15px 0; font-size: 1rem;"></div>
            <button class="btn" style="background:var(--target); padding: 12px 30px;" onclick="game.nextLevel()">SIRADAKƒ∞ ‚ñ∂</button>
        </div>
    </div>

    <script>
        const PHI = (1 + Math.sqrt(5)) / 2;
        const COLORS = { normal: 0x38bdf8, snapped: 0xfacc15, target: 0x00ff88, danger: 0xff0000, safe: 0x4ade80, surface: 0x00ff88 };

        const POLYTOPES = [
            { name: "Tetrahedron", nodes: [[1,1,1], [1,-1,-1], [-1,1,-1], [-1,-1,1]], edges: [[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]], faces: [[0,1,2],[0,2,3],[0,3,1],[1,3,2]], scale: 28, time: 30 },
            { name: "K√ºp", nodes: [[1,1,1], [1,1,-1], [1,-1,1], [1,-1,-1], [-1,1,1], [-1,1,-1], [-1,-1,1], [-1,-1,-1]], edges: [[0,1],[0,2],[0,4],[1,3],[1,5],[2,3],[2,6],[3,7],[4,5],[4,6],[5,7],[6,7]], faces: [[0,2,3],[0,3,1],[4,5,7],[4,7,6],[0,1,5],[0,5,4],[2,6,7],[2,7,3],[0,4,6],[0,6,2],[1,3,7],[1,7,5]], scale: 22, time: 45 },
            { name: "Octahedron", nodes: [[1,0,0], [-1,0,0], [0,1,0], [0,-1,0], [0,0,1], [0,0,-1]], edges: [[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]], faces: [[0,2,4],[0,4,3],[0,3,5],[0,5,2],[1,2,5],[1,5,3],[1,3,4],[1,4,2]], scale: 30, time: 40 },
            { name: "Kare Piramit", nodes: [[0,0,1.4], [1,1,0], [1,-1,0], [-1,1,0], [-1,-1,0]], edges: [[0,1],[0,2],[0,3],[0,4],[1,2],[2,4],[4,3],[3,1]], faces: [[0,1,2],[0,2,4],[0,4,3],[0,3,1],[1,2,3,4]], scale: 30, time: 40 },
            { name: "√ú√ßgen Prizma", nodes: [[1,0,1], [-0.5,0.86,1], [-0.5,-0.86,1], [1,0,-1], [-0.5,0.86,-1], [-0.5,-0.86,-1]], edges: [[0,1],[1,2],[2,0],[3,4],[4,5],[5,3],[0,3],[1,4],[2,5]], faces: [[0,1,2],[3,5,4],[0,3,4,1],[1,4,5,2],[2,5,3,0]], scale: 28, time: 50 },
            { name: "Be≈ügen Piramit", nodes: (()=>{let v=[[0,0,1.5]]; for(let i=0; i<5; i++){let a=(i/5)*Math.PI*2; v.push([Math.cos(a),Math.sin(a),0])} return v})(), edges: [[0,1],[0,2],[0,3],[0,4],[0,5],[1,2],[2,3],[3,4],[4,5],[5,1]], faces: [[0,1,2],[0,2,3],[0,3,4],[0,4,5],[0,5,1],[1,2,3,4,5]], scale: 32, time: 60 },
            { name: "Altƒ±gen Prizma", nodes: (()=>{let v=[]; for(let i=0; i<6; i++){let a=(i/6)*Math.PI*2; v.push([Math.cos(a),Math.sin(a),1],[Math.cos(a),Math.sin(a),-1])} return v})(), autoEdge: 1.2, scale: 28, time: 80 },
            { name: "K√ºpoktay√ºz", nodes: (()=>{let v=[]; for(let i of [-1,1])for(let j of [-1,1]) v.push([i,j,0],[i,0,j],[0,i,j]); return v})(), autoEdge: 1.5, scale: 28, time: 100 },
            { name: "Onikiy√ºzl√º", nodes: (()=>{let v=[]; for(let x of [-1,1])for(let y of [-1,1])for(let z of [-1,1]) v.push([x,y,z]); for(let i of [-1,1]){v.push([0,i*PHI,i/PHI],[0,i*PHI,-i/PHI],[i/PHI,0,i*PHI],[-i/PHI,0,i*PHI],[i/PHI,i/PHI,0],[i*PHI,-i/PHI,0])} return v})(), autoEdge: 1.25, scale: 20, time: 120 },
            { name: "Yirmiy√ºzl√º", nodes: (()=>{let v=[]; for(let i of [-1,1]){v.push([0,i,i*PHI],[0,i,-i*PHI],[i,i*PHI,0],[i,-i*PHI,0],[i*PHI,0,i],[i*PHI,0,-i])} return v})(), autoEdge: 1.25, scale: 22, time: 150 }
        ];

        class Game {
            constructor() {
                this.currentLevel = 0; 
                this.unlockedLevel = parseInt(localStorage.getItem('polyMax')) || 0;
                this.totalScore = parseInt(localStorage.getItem('polyScore')) || 0;
                this.levelScore = 0;
                this.isCelebrating = false;
                
                this.nodes = []; this.edges = []; this.targetPoints = []; this.isSolved = false;
                this.scene = new THREE.Scene();

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
                this.camera.position.set(0, 80, 140);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                document.body.appendChild(this.renderer.domElement);

                this.scene.add(new THREE.AmbientLight(0xffffff, 0.4));
                const sun = new THREE.PointLight(0x38bdf8, 2, 400); sun.position.set(50, 100, 50); this.scene.add(sun);

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;

                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.dragPlane = new THREE.Plane();
                this.pIntersect = new THREE.Vector3();
                this.draggedNode = null;
                this.hasMoved = false;

                window.addEventListener('pointerdown', e => this.onPointerDown(e));
                window.addEventListener('pointermove', e => this.onPointerMove(e));
                window.addEventListener('pointerup', () => this.onPointerUp());
                window.addEventListener('resize', () => this.onResize());

                this.initMenu();
                this.animate();
                this.updateGlobalUI();
            }

            getCurrentReward() {
                const data = POLYTOPES[this.currentLevel];
                const elapsed = (Date.now() - this.startTime) / 1000;
                const period = Math.floor(elapsed / data.time);
                let base = (this.currentLevel >= 3) ? 100 * Math.pow(2, this.currentLevel - 2) : 100;
                return Math.max(5, Math.floor(base / Math.pow(2, period)));
            }

            updateGlobalUI() { document.getElementById('total-score').innerText = this.totalScore; }

            initMenu() {
                const grid = document.getElementById('menu-grid'); grid.innerHTML = '';
                POLYTOPES.forEach((p, i) => {
                    const item = document.createElement('div');
                    const isLocked = i > this.unlockedLevel;
                    item.className = `menu-item ${isLocked ? 'locked' : ''}`;
                    item.innerText = isLocked ? 'üîí' : i + 1;
                    if(!isLocked) item.onclick = () => { this.currentLevel = i; this.startLevel(); };
                    grid.appendChild(item);
                });
            }

            showMenu() { 
                this.isSolved = true; this.isCelebrating = false; this.controls.autoRotate = false;
                document.getElementById('main-menu').style.display = 'flex'; 
                document.getElementById('ui').style.display = 'none'; 
                this.initMenu();
            }

            startLevel() {
                document.getElementById('main-menu').style.display = 'none';
                document.getElementById('ui').style.display = 'block';
                document.getElementById('win-screen').style.display = 'none';
                
                while(this.scene.children.length > 2) this.scene.remove(this.scene.children[this.scene.children.length-1]);
                this.nodes = []; this.edges = []; this.targetPoints = []; this.isSolved = false; this.isCelebrating = false;
                this.controls.autoRotate = false;
                this.hasMoved = false; 
                this.levelScore = 0;
                this.startTime = Date.now();

                const data = POLYTOPES[this.currentLevel];
                document.getElementById('target-name').innerText = data.name;

                // Hedef Noktalar (Ghost form)
                data.nodes.forEach((p, i) => {
                    const pos = new THREE.Vector3(p[0], p[1], p[2]).multiplyScalar(data.scale);
                    this.targetPoints.push({ pos });
                    const mTarget = new THREE.Mesh(new THREE.SphereGeometry(2.5, 8, 8), new THREE.MeshBasicMaterial({ color: COLORS.target, transparent: true, opacity: 0.05 }));
                    mTarget.position.copy(pos); this.scene.add(mTarget);
                });

                // Oyuncu D√ºƒü√ºmleri (Dƒ±≈ü kabuk daƒüƒ±lƒ±mƒ±)
                let scatterRadius = 85 + (data.nodes.length * 2); 
                data.nodes.forEach((p, i) => {
                    const mNode = new THREE.Mesh(new THREE.SphereGeometry(5, 32, 32), new THREE.MeshStandardMaterial({ color: COLORS.normal, metalness: 0.9, roughness: 0.1, emissive: COLORS.normal, emissiveIntensity: 0.2 }));
                    const phi = Math.acos(-1 + (2 * i) / data.nodes.length);
                    const theta = Math.sqrt(data.nodes.length * Math.PI) * phi;
                    mNode.position.set(scatterRadius * Math.cos(theta) * Math.sin(phi), scatterRadius * Math.sin(theta) * Math.sin(phi), scatterRadius * Math.cos(phi));
                    mNode.userData = { onRail: false };
                    this.scene.add(mNode); this.nodes.push(mNode);
                });

                // Halatlar / Kenarlar
                let pairs = data.edges || [];
                if (data.autoEdge) {
                    pairs = [];
                    for(let i=0; i<this.nodes.length; i++) {
                        for(let j=i+1; j<this.nodes.length; j++) {
                            if (this.targetPoints[i].pos.distanceTo(this.targetPoints[j].pos) < data.scale * data.autoEdge + 1) pairs.push([i, j]);
                        }
                    }
                }
                pairs.forEach(p => {
                    const geo = new THREE.CylinderGeometry(0.9, 0.9, 1, 12);
                    geo.rotateX(Math.PI/2); geo.translate(0, 0, 0.5);
                    const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: COLORS.normal, transparent: true, opacity: 0.7, emissive: COLORS.normal, emissiveIntensity: 0.5 }));
                    this.scene.add(mesh);
                    this.edges.push({ mesh, n1: this.nodes[p[0]], n2: this.nodes[p[1]] });
                });

                // Hedef Hayalet ≈ûekil (D√úZELTME: depthWrite: false)
                if (data.faces) {
                    const geo = new THREE.BufferGeometry();
                    const indicesFaces = [];
                    data.faces.forEach(f => { for(let i=1; i<f.length-1; i++) indicesFaces.push(f[0], f[i], f[i+1]); });
                    geo.setFromPoints(this.targetPoints.map(t => t.pos)); geo.setIndex(indicesFaces); geo.computeVertexNormals();
                    // depthWrite: false sayesinde arkadaki halatlarƒ±n g√∂r√ºnmesini engellemez
                    this.surfaceMesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: COLORS.surface, transparent: true, opacity: 0.015, side: THREE.DoubleSide, emissive: COLORS.surface, emissiveIntensity: 0.05, depthWrite: false }));
                    this.scene.add(this.surfaceMesh);
                }

                this.updateLines();
            }

            onPointerDown(e) {
                if(this.isSolved) return;
                this.updateMouse(e);
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const hits = this.raycaster.intersectObjects(this.nodes);
                if(hits.length > 0) {
                    this.draggedNode = hits[0].object;
                    this.lastSafePos = this.nodes.map(n => n.position.clone());
                    this.controls.enabled = false;
                    const normal = new THREE.Vector3();
                    this.camera.getWorldDirection(normal);
                    this.dragPlane.setFromNormalAndCoplanarPoint(normal.negate(), this.draggedNode.position);
                    this.hasMoved = true; 
                }
            }

            onPointerMove(e) {
                if(!this.draggedNode || this.isSolved) return;
                this.updateMouse(e);
                this.raycaster.setFromCamera(this.mouse, this.camera);
                if(this.raycaster.ray.intersectPlane(this.dragPlane, this.pIntersect)) {
                    this.draggedNode.position.copy(this.pIntersect);
                    let foundSnap = false;
                    for(let tp of this.targetPoints) {
                        if(this.draggedNode.position.distanceTo(tp.pos) < 9) {
                            const isOccupied = this.nodes.some(n => n !== this.draggedNode && n.position.distanceTo(tp.pos) < 1);
                            if(!isOccupied) {
                                this.draggedNode.position.copy(tp.pos);
                                if (!this.draggedNode.userData.onRail) {
                                    this.triggerScore(this.draggedNode.position);
                                    this.draggedNode.userData.onRail = true;
                                }
                                foundSnap = true; break;
                            }
                        }
                    }
                    if(!foundSnap) this.draggedNode.userData.onRail = false;
                    this.draggedNode.material.color.setHex(foundSnap ? COLORS.snapped : COLORS.normal);
                    this.draggedNode.material.emissive.setHex(foundSnap ? COLORS.snapped : COLORS.normal);
                    this.updateLines();
                    this.updateProgress();
                    if(this.hasMoved && this.detectCollision(2.0)) this.triggerCollisionLock();
                }
            }

            triggerScore(pos) {
                const gain = this.getCurrentReward();
                this.levelScore += gain;
                this.showScoreEffect(pos, gain);
            }

            showScoreEffect(pos, val) {
                const vector = pos.clone().project(this.camera);
                const div = document.createElement('div');
                div.className = 'score-float';
                div.style.left = (vector.x * 0.5 + 0.5) * window.innerWidth + 'px';
                div.style.top = (vector.y * -0.5 + 0.5) * window.innerHeight + 'px';
                div.innerText = "+" + val;
                document.body.appendChild(div);
                setTimeout(() => div.remove(), 1000);
            }

            onPointerUp() {
                if(!this.draggedNode) return;
                this.draggedNode = null;
                this.controls.enabled = true;
                let snappedCount = this.nodes.filter(n => n.userData.onRail).length;
                if(!this.isSolved && snappedCount === this.nodes.length) this.complete();
            }

            updateMouse(e) { this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1; this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1; }

            updateLines() { 
                this.edges.forEach(e => { 
                    const d = e.n1.position.distanceTo(e.n2.position); 
                    e.mesh.position.copy(e.n1.position); 
                    e.mesh.scale.set(1, 1, d); 
                    e.mesh.lookAt(e.n2.position); 
                }); 
            }

            updateProgress() {
                let snappedCount = this.nodes.filter(n => n.userData.onRail).length;
                let perc = Math.floor((snappedCount / this.nodes.length) * 100);
                document.getElementById('bar-fill').style.width = perc + '%';
                document.getElementById('percent-val').innerText = perc;
            }

            detectCollision(limit) {
                for(let i=0; i<this.edges.length; i++) {
                    for(let j=i+1; j<this.edges.length; j++) {
                        const e1 = this.edges[i], e2 = this.edges[j];
                        if(e1.n1===e2.n1 || e1.n1===e2.n2 || e1.n2===e2.n1 || e1.n2===e2.n2) continue;
                        if(this.getLineDist(e1.n1.position, e1.n2.position, e2.n1.position, e2.n2.position) < limit) return true;
                    }
                } return false;
            }

            triggerCollisionLock() { this.draggedNode = null; this.controls.enabled = false; document.getElementById('collision-lock').style.display = 'flex'; }
            
            restoreSafeState() {
                this.nodes.forEach((n, i) => { 
                    n.position.copy(this.lastSafePos[i]); 
                    let isSnapped = this.targetPoints.some(tp => n.position.distanceTo(tp.pos) < 1);
                    n.userData.onRail = isSnapped;
                    n.material.color.setHex(isSnapped ? COLORS.snapped : COLORS.normal);
                });
                this.controls.enabled = true; 
                document.getElementById('collision-lock').style.display = 'none'; 
                this.updateLines(); 
                this.updateProgress();
            }

            getLineDist(p1, p2, p3, p4) {
                const u = p2.clone().sub(p1), v = p4.clone().sub(p3), w = p1.clone().sub(p3);
                const a = u.dot(u), b = u.dot(v), c = v.dot(v), d = u.dot(w), e = v.dot(w);
                const D = a*c - b*b; let sc, tc;
                if (D < 0.001) { sc = 0; tc = b > c ? d/b : e/c; } else { sc = (b*e - c*d)/D; tc = (a*e - b*d)/D; }
                return p1.clone().add(u.multiplyScalar(Math.max(0,Math.min(1,sc)))).distanceTo(p3.clone().add(v.multiplyScalar(Math.max(0,Math.min(1,tc)))));
            }

            complete() {
                this.isSolved = true; this.isCelebrating = true; this.controls.autoRotate = true;
                const bonus = (this.currentLevel >= 3) ? 500 * Math.pow(2, this.currentLevel - 2) : 500;
                this.levelScore += bonus; this.totalScore += this.levelScore;
                if(this.currentLevel === this.unlockedLevel) this.unlockedLevel++;
                localStorage.setItem('polyMax', this.unlockedLevel);
                localStorage.setItem('polyScore', this.totalScore);
                this.updateGlobalUI();
                this.nodes.forEach(n => { n.material.color.setHex(0xffd700); n.material.emissiveIntensity = 1; });
                this.edges.forEach(e => { e.mesh.material.color.setHex(0xffd700); e.mesh.material.emissiveIntensity = 1; });
                if(this.surfaceMesh) { 
                    this.surfaceMesh.material.opacity = 0.5; 
                    this.surfaceMesh.material.color.setHex(0x4ade80); 
                    this.surfaceMesh.material.depthWrite = true; // Kazanƒ±nca y√ºzeyi netle≈ütir
                }
                setTimeout(() => {
                    document.getElementById('win-screen').style.display = 'flex';
                    document.getElementById('win-stats').innerHTML = `SKOR: ${this.levelScore} <br> <span style="font-size:0.8rem; color:var(--gold)">+${bonus} BONUS PUAN</span>`;
                }, 2000);
            }

            resetData() { if(confirm("T√ºm ilerleme sƒ±fƒ±rlanacak?")) { localStorage.clear(); location.reload(); } }
            nextLevel() { this.currentLevel = Math.min(this.currentLevel + 1, POLYTOPES.length - 1); this.startLevel(); }
            onResize() { this.camera.aspect = window.innerWidth / window.innerHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(window.innerWidth, window.innerHeight); }

            animate() { 
                requestAnimationFrame(() => this.animate()); 
                this.controls.update(); 
                if(!this.isSolved) {
                    const elapsed = (Date.now() - this.startTime) / 1000;
                    const data = POLYTOPES[this.currentLevel];
                    const rem = Math.max(0, data.time - (elapsed % data.time));
                    document.getElementById('timer-display').innerText = rem.toFixed(1);
                    document.getElementById('current-reward').innerText = this.getCurrentReward();
                    const glow = 0.3 + Math.sin(Date.now() * 0.005) * 0.2;
                    this.edges.forEach(e => e.mesh.material.emissiveIntensity = glow);
                }
                this.renderer.render(this.scene, this.camera); 
            }
        }
        const game = new Game();
    </script>
</body>
</html>