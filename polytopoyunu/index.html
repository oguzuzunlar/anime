<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ã‡okyÃ¼zlÃ¼ Restorasyonu - Topolojik DÃ¼ÄŸÃ¼m</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* MEB Uyumlu Fontlar: OkunaklÄ± ve TÃ¼rkÃ§e karakter destekli standart fontlar */
        :root { --neon: #38bdf8; --target: #4ade80; --danger: #ef4444; --gold: #facc15; }
        
        body { 
            margin: 0; overflow: hidden; 
            background-color: #000;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%); 
            font-family: 'Segoe UI', 'Calibri', 'Arial', sans-serif; 
            touch-action: none; 
            color: #e2e8f0; 
        }
        
        canvas { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            z-index: 0; 
            outline: none; 
        }

        #top-bar { 
            position: fixed; top: 10px; left: 0; width: 100%; 
            display: flex; justify-content: flex-start; align-items: center; flex-wrap: wrap; 
            padding: 0 120px 0 20px; box-sizing: border-box; z-index: 2000; pointer-events: none; gap: 12px;
        }
        .ui-box { 
            background: rgba(15, 23, 42, 0.8); border: 1px solid var(--neon); 
            padding: 8px 15px; border-radius: 12px; color: var(--neon); 
            font-size: 0.8rem; pointer-events: auto; backdrop-filter: blur(5px);
        }
        .reward-badge { border-color: var(--gold); color: var(--gold); }

        /* GÃœNCELLEME: justify-content: flex-start ile taÅŸma sorunu Ã§Ã¶zÃ¼ldÃ¼ */
        #main-menu { 
            position: fixed; inset: 0; background: transparent; 
            z-index: 3000; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; 
            padding: 80px 20px 80px 20px; overflow-y: auto; box-sizing: border-box; 
        }
        .menu-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; margin-top: 20px; }
        .menu-item { 
            width: 60px; height: 60px; background: rgba(56, 189, 248, 0.1); border: 1px solid #38bdf8; 
            color: #38bdf8; display: flex; align-items: center; justify-content: center; 
            border-radius: 10px; cursor: pointer; font-weight: bold; transition: 0.3s; 
        }
        .menu-item.locked { opacity: 0.3; cursor: not-allowed; border-color: #444; color: #444; }
        .menu-item:not(.locked):hover { background: #38bdf8; color: #000; box-shadow: 0 0 20px #38bdf8; }

        #ui { position: absolute; top: 80px; left: 20px; width: 220px; pointer-events: none; z-index: 100; display: none; }
        .panel { background: rgba(10, 20, 40, 0.9); border: 2px solid var(--neon); padding: 12px; border-radius: 15px; color: var(--neon); pointer-events: auto; }
        .bar-bg { background: #000; height: 8px; border-radius: 4px; margin: 10px 0; border: 1px solid #1e293b; overflow: hidden; }
        #bar-fill { background: var(--target); height: 100%; width: 0%; transition: width 0.3s; }
        .panel-header { display: flex; justify-content: space-between; align-items: center; gap: 10px; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.08em; margin-bottom: 8px; }
        .panel-toggle { background: rgba(56, 189, 248, 0.12); border: 1px solid rgba(56, 189, 248, 0.4); color: var(--neon); border-radius: 10px; padding: 4px 10px; font-size: 0.65rem; cursor: pointer; }
        .panel-toggle:hover { background: rgba(56, 189, 248, 0.3); color: #000; }
        .panel-body { display: flex; flex-direction: column; gap: 8px; }
        .panel-timer { font-size: 1.5rem; font-weight: bold; text-align: center; }
        .panel-target { margin: 5px 0; font-size: 0.75rem; text-align: center; }
        .panel-progress { font-size: 0.6rem; text-align: center; color: #94a3b8; }
        .panel.collapsed { padding: 10px 12px; }
        .panel.collapsed .panel-body { display: none; }
        .panel.collapsed .panel-toggle { background: rgba(56, 189, 248, 0.2); }

        
        .btn { background: var(--neon); border: none; color: #000; padding: 10px 20px; border-radius: 30px; cursor: pointer; font-weight: bold; pointer-events: auto; text-transform: uppercase; transition: 0.3s; margin-top: 10px; }
        .secondary-btn { background: rgba(56, 189, 248, 0.15); color: var(--neon); border: 1px solid rgba(56, 189, 248, 0.5); }
        .secondary-btn:hover { background: rgba(56, 189, 248, 0.35); color: #000; }

        #help-fab { position: fixed; top: 12px; right: 20px; z-index: 2100; pointer-events: auto; font-size: 0.65rem; padding: 8px 14px; }

        #collision-lock { position: fixed; inset: 0; background: rgba(150, 0, 0, 0.7); backdrop-filter: blur(10px); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 5000; }
        
        #win-screen { 
            position: fixed; inset: 0; background: radial-gradient(circle, transparent 0%, rgba(0,0,0,0.8) 100%); 
            display: none; flex-direction: column; justify-content: flex-end; align-items: center; 
            z-index: 6000; padding-bottom: 50px; pointer-events: none;
        }
        .win-content { background: rgba(0,0,0,0.9); border: 2px solid var(--target); padding: 30px; border-radius: 20px; pointer-events: auto; text-align: center; }

        #help-overlay { position: fixed; inset: 0; background: rgba(2, 6, 23, 0.92); z-index: 7000; display: none; align-items: center; justify-content: center; padding: 30px; box-sizing: border-box; }
        .help-card { max-width: 520px; width: 100%; background: rgba(15, 23, 42, 0.95); border: 2px solid var(--neon); border-radius: 18px; padding: 20px 24px; box-shadow: 0 20px 60px rgba(56, 189, 248, 0.25); }
        .help-card h2 { margin: 0 0 12px 0; font-size: 1.5rem; color: var(--neon); text-align: center; }
        .help-card h3 { margin: 18px 0 8px 0; font-size: 1rem; color: var(--gold); }
        .help-card p, .help-card li { font-size: 0.85rem; line-height: 1.5; color: #cbd5f5; }
        .help-card ul { margin: 0; padding-left: 20px; }
        .help-actions { display: flex; justify-content: center; margin-top: 20px; }

        .score-float { 
            position: absolute; color: var(--target); font-weight: 900; font-size: 24px; 
            pointer-events: none; z-index: 10000; text-shadow: 0 0 8px #000; 
            animation: floatUp 1s ease-out forwards;
        }
        @keyframes floatUp { 0% { transform: translateY(0); opacity: 0; } 20% { opacity: 1; } 100% { transform: translateY(-100px); opacity: 0; } }

        .info-card { 
            margin-top: 30px; margin-bottom: 50px; max-width: 540px; 
            background: rgba(15, 23, 42, 0.85); border: 1px solid rgba(56, 189, 248, 0.4); 
            border-radius: 16px; padding: 20px 24px; font-size: 0.9rem; color: #cbd5f5; line-height: 1.7; 
        }
        .info-card h3 { margin: 0 0 10px 0; font-size: 1rem; color: var(--neon); text-align: center; }

        @media (max-width: 900px) {
            .menu-grid { grid-template-columns: repeat(3, 1fr); }
            .menu-item { width: 56px; height: 56px; font-size: 0.9rem; }
            #top-bar { flex-direction: column; gap: 8px; align-items: flex-start; padding: 0 16px; }
            #main-menu { justify-content: flex-start; padding-top: 120px; }
            #ui { top: 70px; left: 10px; width: 180px; }
            .panel { padding: 10px; }
            .btn { font-size: 0.65rem; padding: 8px 16px; }
            #help-fab { top: 12px; right: 16px; }
        }

        @media (max-width: 600px) {
            body { font-size: 14px; }
            #main-menu h1 { font-size: 1.4rem; }
            .menu-grid { grid-template-columns: repeat(2, 1fr); gap: 12px; }
            .menu-item { width: 52px; height: 52px; }
            #top-bar { padding: 0 12px; gap: 6px; }
            .ui-box { font-size: 0.7rem; padding: 6px 12px; }
            #ui { width: calc(100% - 20px); left: 10px; right: 10px; top: 70px; }
            .panel { border-radius: 12px; }
            #collision-lock > div { width: calc(100% - 40px); }
            .help-card { padding: 18px; }
            .help-card h2 { font-size: 1.25rem; }
            .help-card p, .help-card li { font-size: 0.8rem; }
            #help-fab { right: 12px; top: 12px; }
            #main-menu { padding-top: 130px; }
        }
    </style>
</head>
<body>

    <div id="top-bar">
        <div class="ui-box">TOPLAM: <span id="total-score">0</span></div>
        <div class="ui-box reward-badge">Ã–DÃœL: <span id="current-reward">100</span></div>
    </div>

    <button id="help-fab" class="btn secondary-btn" onclick="game.openHelp()">YARDIM â”</button>

    <div id="main-menu">
        <h1 style="color:#38bdf8; text-shadow: 0 0 15px #38bdf8; text-align: center; font-size: 1.8rem; margin: 0;">Ã‡OKYÃœZLÃœ RESTORASYONU</h1>
        <p style="color: #64748b; font-size: 0.8rem; margin-bottom: 20px;">Topolojik dÃ¼ÄŸÃ¼mÃ¼ Ã§Ã¶zÃ¼n ve formu restore edin.</p>
        <div class="menu-grid" id="menu-grid"></div>
        <div style="display:flex; gap:12px; margin-top:20px; flex-wrap:wrap; justify-content:center;">
            <button class="btn secondary-btn" style="font-size:0.65rem;" onclick="game.openHelp()">NASIL OYNANIR?</button>
            <button class="btn" style="background: transparent; color: #444; border: 1px solid #444; font-size: 0.6rem;" onclick="game.resetData()">OYUNU SIFIRLA</button>
        </div>
        <div class="info-card" id="menu-info">
            <h3>NasÄ±l OynanÄ±r?</h3>
            <p>Her seviyede daÄŸÄ±lmÄ±ÅŸ dÃ¼ÄŸÃ¼mleri sÃ¼rÃ¼kleyin ve hayalet hedef ÅŸeklin kÃ¶ÅŸelerine yerleÅŸtirin. Sadece kÃ¶ÅŸeleri doldurmak yetmez; kenarlarÄ±n da hedef ÅŸekle birebir uymasÄ± gerekir. TÃ¼m dÃ¼ÄŸÃ¼mler doÄŸru konuma ve doÄŸru baÄŸlantÄ± yapÄ±sÄ±na ulaÅŸtÄ±ÄŸÄ±nda ÅŸekil restore olur.</p>
            <h3>Puanlama</h3>
            <p>Her yerleÅŸtirmede gÃ¼ncel Ã¶dÃ¼l puanÄ± kazanÄ±rsÄ±nÄ±z. Seviye sÃ¼resi arttÄ±kÃ§a puan azalÄ±r. Ã‡akÄ±ÅŸma uyarÄ±sÄ± alÄ±rsanÄ±z 'GERÄ° AL' diyerek son gÃ¼venli duruma dÃ¶nÃ¼n.</p>
            <h3>Joker KullanÄ±mÄ±</h3>
            <p>Her seviyede bir kez 'Ä°LK ADIM JOKERÄ°' kullanabilirsiniz. Bu joker, yerleÅŸmemiÅŸ dÃ¼ÄŸÃ¼mlerden birini otomatik olarak doÄŸru hedefine yerleÅŸtirir. Joker kullanmak o anki seviye puanÄ±nÄ±zÄ± yarÄ±ya dÃ¼ÅŸÃ¼rÃ¼r.</p>
            <h3>Kontroller</h3>
            <ul>
                <li>Dokunun veya tÄ±klayÄ±n: DÃ¼ÄŸÃ¼mÃ¼ seÃ§in ve sÃ¼rÃ¼kleyin.</li>
                <li>Ä°ki parmakla sÃ¼rÃ¼kleyin / fare saÄŸ tuÅŸunu basÄ±lÄ± tutun: KamerayÄ± dÃ¶ndÃ¼rÃ¼n.</li>
                <li>Ä°ki parmakla kÄ±stÄ±rÄ±n / fare tekerleÄŸini kullanÄ±n: YakÄ±nlaÅŸtÄ±rÄ±n veya uzaklaÅŸtÄ±rÄ±n.</li>
            </ul>
        </div>
    </div>

    <div id="ui">
        <div class="panel" id="ui-panel">
            <div class="panel-header">
                <span>SEVÄ°YE PANELÄ°</span>
                <button id="panel-toggle" class="panel-toggle" onclick="game.toggleUIPanel()">GÄ°ZLE</button>
            </div>
            <div class="panel-body">
                <div style="text-align: center; color: var(--gold); font-size: 0.9rem; font-weight: bold; margin-bottom: 5px;">SEVÄ°YE: <span id="current-level-display">1</span></div>
                <div id="timer-display" class="panel-timer">00.0</div>
                <h2 id="target-name" class="panel-target">-</h2>
                <div class="bar-bg"><div id="bar-fill"></div></div>
                <div class="panel-progress">UYUM: %<span id="percent-val">0</span></div>
                <button id="joker-btn" class="btn" style="width: 100%; font-size: 0.7rem; background: #f59e0b; color: #000; font-weight: 800; display: none;" onclick="game.useJoker()">
                    âœ¨ Ä°LK ADIM JOKERÄ°
                </button>
                <button class="btn secondary-btn" style="width: 100%; font-size: 0.7rem;" onclick="game.openHelp()">YARDIM â”</button>
                <button class="btn" style="width: 100%; font-size: 0.7rem;" onclick="game.showMenu()">ANA MENÃœ ğŸ </button>
            </div>
        </div>
    </div>

    <div id="collision-lock">
        <div style="background:#000; padding:30px; border-radius:20px; border:3px solid #f00; text-align:center;">
            <h2 style="color:#f00; margin:0 0 10px 0;">ğŸ›‘ Ã‡AKIÅMA!</h2>
            <p style="color:#fff; font-size:0.75rem; margin-bottom: 15px;">DÃ¼ÄŸÃ¼mler arasÄ± geÃ§iÅŸ engellendi.</p>
            <button class="btn" style="background:#f00; color:#fff;" onclick="game.restoreSafeState()">GERÄ° AL</button>
        </div>
    </div>

    <div id="win-screen">
        <div class="win-content">
            <h1 id="win-title" style="color:var(--target); font-size: 2rem; margin: 0;">BAÅARILI!</h1>
            <div id="win-stats" style="color:#fff; margin: 15px 0; font-size: 1rem;"></div>
            <button id="next-btn" class="btn" style="background:var(--target); padding: 12px 30px;" onclick="game.nextLevel()">SIRADAKÄ° â–¶</button>
        </div>
    </div>

    <!-- Havai FiÅŸek KonteynÄ±rÄ± -->
    <div id="fireworks-container" style="position: fixed; inset: 0; pointer-events: none; z-index: 6500; display: none;"></div>

    <div id="help-overlay">
        <div class="help-card">
            <h2>NasÄ±l OynanÄ±r?</h2>
            <p>DaÄŸÄ±lmÄ±ÅŸ dÃ¼ÄŸÃ¼mleri sÃ¼rÃ¼kleyin ve yeÅŸil hayalet ÅŸeklin kÃ¶ÅŸelerine yerleÅŸtirin. Sadece kÃ¶ÅŸeleri doldurmak yetmez; kenarlarÄ±n da hedef ÅŸekle birebir uymasÄ± gerekir.</p>
            <h3>Puanlama</h3>
            <ul>
                <li>Her baÅŸarÄ±lÄ± yerleÅŸimde o anki Ã¶dÃ¼l puanÄ±nÄ± kazanÄ±rsÄ±nÄ±z.</li>
                <li>Ã–dÃ¼l, seviye sÃ¼resi arttÄ±kÃ§a azalÄ±r. Ne kadar hÄ±zlÄ± olursanÄ±z o kadar fazla puan toplarsÄ±nÄ±z.</li>
                <li>Ã‡akÄ±ÅŸma uyarÄ±sÄ± aldÄ±ÄŸÄ±nÄ±zda 'GERÄ° AL' seÃ§eneÄŸiyle son gÃ¼venli konuma dÃ¶nersiniz.</li>
            </ul>
            <h3>Joker KullanÄ±mÄ±</h3>
            <ul>
                <li>Seviye baÅŸÄ±na bir adet 'Ä°LK ADIM JOKERÄ°' hakkÄ±nÄ±z vardÄ±r.</li>
                <li>Joker kullanÄ±ldÄ±ÄŸÄ±nda, henÃ¼z yerleÅŸmemiÅŸ rastgele bir dÃ¼ÄŸÃ¼m doÄŸru konumuna otomatik olarak taÅŸÄ±nÄ±r.</li>
                <li>Joker kullanÄ±mÄ±nda o anki seviye puanÄ±nÄ±z %50 oranÄ±nda azalÄ±r.</li>
            </ul>
            <h3>Kontroller</h3>
            <ul>
                <li>Dokunun ve sÃ¼rÃ¼kleyin / fare sol tuÅŸunu basÄ±lÄ± tutun: DÃ¼ÄŸÃ¼mÃ¼ hareket ettirin.</li>
                <li>Ä°ki parmakla sÃ¼rÃ¼kleyin / fare saÄŸ tuÅŸunu basÄ±lÄ± tutun: KamerayÄ± dÃ¶ndÃ¼rÃ¼n.</li>
                <li>Ä°ki parmakla kÄ±stÄ±rÄ±n / fare tekerleÄŸini kullanÄ±n: YakÄ±nlaÅŸtÄ±rÄ±n veya uzaklaÅŸtÄ±rÄ±n.</li>
            </ul>
            <div class="help-actions">
                <button class="btn" style="width: 160px;" onclick="game.closeHelp()">KAPAT</button>
            </div>
        </div>
    </div>

    <div id="reset-modal" style="position: fixed; inset: 0; background: rgba(2, 6, 23, 0.95); z-index: 8000; display: none; align-items: center; justify-content: center; padding: 20px;">
        <div class="help-card" style="max-width: 400px; text-align: center; border-color: var(--danger);">
            <h2 style="color: var(--danger);">âš ï¸ DÄ°KKAT</h2>
            <p>TÃ¼m ilerlemeniz ve toplam puanÄ±nÄ±z kalÄ±cÄ± olarak silinecektir. Devam etmek istediÄŸinize emin misiniz?</p>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 25px;">
                <button class="btn" style="background: var(--danger); color: white; margin: 0; min-width: 100px;" onclick="game.confirmReset()">EVET, SIFIRLA</button>
                <button class="btn secondary-btn" style="margin: 0; min-width: 100px;" onclick="game.closeResetModal()">Ä°PTAL</button>
            </div>
        </div>
    </div>

    <script>
        const PHI = (1 + Math.sqrt(5)) / 2;
        const COLORS = { normal: 0x38bdf8, snapped: 0xfacc15, target: 0x00ff88, danger: 0xff0000, safe: 0x4ade80, surface: 0x00ff88 };

        const POLYTOPES = [
            { name: "DÃ¶rtyÃ¼zlÃ¼", nodes: [[1,1,1], [1,-1,-1], [-1,1,-1], [-1,-1,1]], edges: [[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]], faces: [[0,1,2],[0,2,3],[0,3,1],[1,3,2]], scale: 28, time: 30 },
            { name: "KÃ¼p", nodes: [[1,1,1], [1,1,-1], [1,-1,1], [1,-1,-1], [-1,1,1], [-1,1,-1], [-1,-1,1], [-1,-1,-1]], edges: [[0,1],[0,2],[0,4],[1,3],[1,5],[2,3],[2,6],[3,7],[4,5],[4,6],[5,7],[6,7]], faces: [[0,2,3],[0,3,1],[4,5,7],[4,7,6],[0,1,5],[0,5,4],[2,6,7],[2,7,3],[0,4,6],[0,6,2],[1,3,7],[1,7,5]], scale: 22, time: 45 },
            { name: "SekizyÃ¼zlÃ¼", nodes: [[1,0,0], [-1,0,0], [0,1,0], [0,-1,0], [0,0,1], [0,0,-1]], edges: [[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]], faces: [[0,2,4],[0,4,3],[0,3,5],[0,5,2],[1,2,5],[1,5,3],[1,3,4],[1,4,2]], scale: 30, time: 40 },
            { name: "Kare Piramit", nodes: [[0,0,1.4], [1,1,0], [1,-1,0], [-1,1,0], [-1,-1,0]], edges: [[0,1],[0,2],[0,3],[0,4],[1,2],[2,4],[4,3],[3,1]], faces: [[0,1,2],[0,2,4],[0,4,3],[0,3,1],[1,2,3,4]], scale: 30, time: 40 },
            { name: "ÃœÃ§gen Prizma", nodes: [[1,0,1], [-0.5,0.86,1], [-0.5,-0.86,1], [1,0,-1], [-0.5,0.86,-1], [-0.5,-0.86,-1]], edges: [[0,1],[1,2],[2,0],[3,4],[4,5],[5,3],[0,3],[1,4],[2,5]], faces: [[0,1,2],[3,5,4],[0,3,4,1],[1,4,5,2],[2,5,3,0]], scale: 28, time: 50 },
            { name: "BeÅŸgen Piramit", nodes: (()=>{let v=[[0,0,1.5]]; for(let i=0; i<5; i++){let a=(i/5)*Math.PI*2; v.push([Math.cos(a),Math.sin(a),0])} return v})(), edges: [[0,1],[0,2],[0,3],[0,4],[0,5],[1,2],[2,3],[3,4],[4,5],[5,1]], faces: [[0,1,2],[0,2,3],[0,3,4],[0,4,5],[0,5,1],[1,2,3,4,5]], scale: 32, time: 60 }
        ];

        class Game {
            constructor() {
                this.currentLevel = 0; 
                this.unlockedLevel = parseInt(localStorage.getItem('polyMax')) || 0;
                if (Number.isNaN(this.unlockedLevel)) this.unlockedLevel = 0;
                this.unlockedLevel = Math.min(Math.max(this.unlockedLevel, 0), POLYTOPES.length - 1);
                this.totalScore = parseInt(localStorage.getItem('polyScore')) || 0;
                this.levelScore = 0;
                this.isCelebrating = false;
                
                this.nodes = []; this.edges = []; this.targetPoints = []; this.isSolved = false;
                this.scene = new THREE.Scene();
                // Arkaplan rengini doÄŸrudan sahneye veriyoruz
                this.scene.background = new THREE.Color(0x020617); 

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 3000);
                this.camera.position.set(0, 80, 140);

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setClearColor(0x020617, 1);
                document.body.appendChild(this.renderer.domElement);

                this.scene.add(new THREE.AmbientLight(0xffffff, 0.4));
                const sun = new THREE.PointLight(0x38bdf8, 2, 400); sun.position.set(50, 100, 50); this.scene.add(sun);

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;

                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.dragPlane = new THREE.Plane();
                this.pIntersect = new THREE.Vector3();
                this.draggedNode = null;
                this.hasMoved = false;
                this.helpOpen = false;
                this.strictSnapping = false;
                this.panelCollapsed = false;
                this.panelPreference = null;
                this.stars = null;

                // SES DOSYALARI
                this.sounds = {
                    bgm: new Audio('bgm.mp3'),
                    click: new Audio('click.mp3'),
                    snap: new Audio('snap.mp3'),
                    collision: new Audio('collision.mp3'),
                    win: new Audio('win.mp3'),
                    undo: new Audio('undo.mp3'),
                    fail: new Audio('fail.mp3')
                };
                this.sounds.bgm.loop = true;
                this.sounds.bgm.volume = 0.4;
                this.audioStarted = false;

                // Mobil iÃ§in ses kilidini aÃ§an olaylar
                const unlockAudio = () => {
                    this.startAudioContext();
                };
                window.addEventListener('pointerdown', unlockAudio);
                window.addEventListener('click', unlockAudio);
                window.addEventListener('touchstart', unlockAudio);

                window.addEventListener('pointermove', e => this.onPointerMove(e));
                window.addEventListener('pointerup', () => this.onPointerUp());
                window.addEventListener('resize', () => this.onResize());

                this.createStarField();
                this.initMenu();
                this.animate();
                this.updateGlobalUI();
                this.updatePanelResponsive();
            }

            createStarField() {
                const geometry = new THREE.BufferGeometry();
                const count = 3000;
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);

                for (let i = 0; i < count; i++) {
                    const r = 300 + Math.random() * 600;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);

                    const x = r * Math.sin(phi) * Math.cos(theta);
                    const y = r * Math.sin(phi) * Math.sin(theta);
                    const z = r * Math.cos(phi);

                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;

                    const colorType = Math.random();
                    if (colorType > 0.9) {
                        colors[i * 3] = 1.0; colors[i * 3 + 1] = 0.9; colors[i * 3 + 2] = 0.7;
                    } else if (colorType > 0.7) {
                        colors[i * 3] = 0.7; colors[i * 3 + 1] = 0.9; colors[i * 3 + 2] = 1.0;
                    } else if (colorType > 0.5) {
                        colors[i * 3] = 0.9; colors[i * 3 + 1] = 0.7; colors[i * 3 + 2] = 1.0;
                    } else {
                        colors[i * 3] = 1.0; colors[i * 3 + 1] = 1.0; colors[i * 3 + 2] = 1.0;
                    }
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: 2.2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    sizeAttenuation: true,
                    depthWrite: false
                });

                this.stars = new THREE.Points(geometry, material);
                this.scene.add(this.stars);
            }

            toggleUIPanel() {
                this.playSound('click');
                this.setPanelCollapsed(!this.panelCollapsed, true);
            }

            setPanelCollapsed(collapsed, manual = false) {
                const panel = document.getElementById('ui-panel');
                const toggleBtn = document.getElementById('panel-toggle');
                if(panel) {
                    const currentlyCollapsed = panel.classList.contains('collapsed');
                    if(currentlyCollapsed !== collapsed) {
                        panel.classList.toggle('collapsed', collapsed);
                    }
                }
                if(toggleBtn) toggleBtn.innerText = collapsed ? 'AÃ‡' : 'GÄ°ZLE';
                this.panelCollapsed = collapsed;
                if(manual) this.panelPreference = collapsed;
            }

            updatePanelResponsive() {
                if(this.panelPreference !== null) {
                    this.setPanelCollapsed(this.panelPreference, false);
                    return;
                }
                const autoCollapse = window.innerWidth < 680;
                this.setPanelCollapsed(autoCollapse, false);
            }

            // SES KONTROLLERÄ°
            startAudioContext() {
                if (this.audioStarted) return;
                
                // Mobil tarayÄ±cÄ±larda (iOS/Android) sesi oynatmak iÃ§in bir kez play() Ã§aÄŸrÄ±lmalÄ±
                this.sounds.bgm.play()
                    .then(() => {
                        this.audioStarted = true;
                        // Kilidi aÃ§tÄ±ktan sonra dinleyicileri kaldÄ±rabiliriz (isteÄŸe baÄŸlÄ±)
                    })
                    .catch(err => {
                        console.log("Ses henÃ¼z Ã§alÄ±namÄ±yor (KullanÄ±cÄ± etkileÅŸimi bekleniyor):", err);
                    });
            }

            playSound(name) {
                if (!this.sounds[name]) return;
                // AynÄ± sesin Ã¼st Ã¼ste binmesi iÃ§in klonlayÄ±p Ã§alÄ±yoruz (BGM hariÃ§)
                if (name === 'bgm') return;
                const s = this.sounds[name].cloneNode();
                s.volume = this.sounds[name].volume;
                s.play().catch(() => {});
            }

            getCurrentReward() {
                const data = POLYTOPES[this.currentLevel];
                const elapsed = (Date.now() - this.startTime) / 1000;
                const period = Math.floor(elapsed / data.time);
                let base = (this.currentLevel >= 3) ? 100 * Math.pow(2, this.currentLevel - 2) : 100;
                return Math.max(5, Math.floor(base / Math.pow(2, period)));
            }

            updateGlobalUI() { document.getElementById('total-score').innerText = this.totalScore; }

            initMenu() {
                const grid = document.getElementById('menu-grid'); grid.innerHTML = '';
                POLYTOPES.forEach((p, i) => {
                    const item = document.createElement('div');
                    const isLocked = i > this.unlockedLevel;
                    item.className = `menu-item ${isLocked ? 'locked' : ''}`;
                    item.innerText = isLocked ? 'ğŸ”’' : i + 1;
                    if(!isLocked) item.onclick = () => { 
                        this.playSound('click');
                        this.currentLevel = i; 
                        this.startLevel(); 
                    };
                    grid.appendChild(item);
                });
            }

            showMenu() { 
                this.playSound('click');
                this.isSolved = true; this.isCelebrating = false; this.controls.autoRotate = false;
                document.getElementById('main-menu').style.display = 'flex'; 
                document.getElementById('ui').style.display = 'none'; 
                this.closeHelp();
                this.initMenu();
            }

            startLevel() {
                document.getElementById('main-menu').style.display = 'none';
                document.getElementById('ui').style.display = 'block';
                document.getElementById('win-screen').style.display = 'none';
                this.closeHelp();
                this.updatePanelResponsive();
                
                // Sahneyi temizle (IÅŸÄ±klarÄ± ve yÄ±ldÄ±zlarÄ± koru: 0, 1, 2 nolu Ã§ocuklarÄ± tut)
                while(this.scene.children.length > 3) this.scene.remove(this.scene.children[this.scene.children.length-1]);
                this.nodes = []; this.edges = []; this.targetPoints = []; this.isSolved = false; this.isCelebrating = false;
                this.controls.autoRotate = false;
                this.hasMoved = false; 
                this.levelScore = 0;
                this.jokerUsed = false;
                document.getElementById('joker-btn').style.display = 'block';
                this.startTime = Date.now();

                const data = POLYTOPES[this.currentLevel];
                this.strictSnapping = !!data.strictTargets;
                document.getElementById('target-name').innerText = data.name;
                document.getElementById('current-level-display').innerText = this.currentLevel + 1;

                // Hedef Noktalar (Ghost form)
                data.nodes.forEach((p, i) => {
                    const pos = new THREE.Vector3(p[0], p[1], p[2]).multiplyScalar(data.scale);
                    this.targetPoints.push({ pos });
                    const mTarget = new THREE.Mesh(new THREE.SphereGeometry(5, 16, 16), new THREE.MeshBasicMaterial({ color: COLORS.target, transparent: true, opacity: 0.25 }));
                    mTarget.position.copy(pos); this.scene.add(mTarget);
                });

                // Oyuncu DÃ¼ÄŸÃ¼mleri (Ã‡Ã¶zÃ¼lebilir daÄŸÄ±lÄ±m)
                data.nodes.forEach((p, i) => {
                    const mNode = new THREE.Mesh(new THREE.SphereGeometry(5, 32, 32), new THREE.MeshStandardMaterial({ color: COLORS.normal, metalness: 0.9, roughness: 0.1, emissive: COLORS.normal, emissiveIntensity: 0.2 }));
                    mNode.userData = { onRail: false, targetIndex: i, currentTarget: null };
                    this.scene.add(mNode); this.nodes.push(mNode);
                });
                
                this.generateSolvableStart(data);

                // Halatlar / Kenarlar
                let pairs = data.edges || [];
                if (data.autoEdge) {
                    pairs = [];
                    for(let i=0; i<this.nodes.length; i++) {
                        for(let j=i+1; j<this.nodes.length; j++) {
                            if (this.targetPoints[i].pos.distanceTo(this.targetPoints[j].pos) < data.scale * data.autoEdge + 1) pairs.push([i, j]);
                        }
                    }
                }
                pairs.forEach(p => {
                    const geo = new THREE.CylinderGeometry(0.9, 0.9, 1, 12);
                    geo.rotateX(Math.PI/2); geo.translate(0, 0, 0.5);
                    const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: COLORS.normal, transparent: true, opacity: 0.7, emissive: COLORS.normal, emissiveIntensity: 0.5 }));
                    this.scene.add(mesh);
                    this.edges.push({ mesh, n1: this.nodes[p[0]], n2: this.nodes[p[1]] });
                });

                // Hedef Hayalet Åekil (DÃœZELTME: depthWrite: false)
                if (data.faces) {
                    const geo = new THREE.BufferGeometry();
                    const indicesFaces = [];
                    data.faces.forEach(f => { for(let i=1; i<f.length-1; i++) indicesFaces.push(f[0], f[i], f[i+1]); });
                    geo.setFromPoints(this.targetPoints.map(t => t.pos)); geo.setIndex(indicesFaces); geo.computeVertexNormals();
                    // depthWrite: false sayesinde arkadaki halatlarÄ±n gÃ¶rÃ¼nmesini engellemez
                    this.surfaceMesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: COLORS.surface, transparent: true, opacity: 0.12, side: THREE.DoubleSide, emissive: COLORS.surface, emissiveIntensity: 0.15, depthWrite: false }));
                    this.scene.add(this.surfaceMesh);
                }

                this.updateLines();
            }

            onPointerDown(e) {
                if(this.isSolved) return;
                this.updateMouse(e);
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const hits = this.raycaster.intersectObjects(this.nodes);
                if(hits.length > 0) {
                    this.playSound('click');
                    this.draggedNode = hits[0].object;
                    this.dragStartPos = this.draggedNode.position.clone(); // BaÅŸlangÄ±Ã§ pozisyonunu kaydet
                    this.hasMoved = false; // Yeni sÃ¼rÃ¼klemede hareket bilgisi sÄ±fÄ±rlansÄ±n
                    this.lastSafePos = this.nodes.map(n => n.position.clone());
                    this.controls.enabled = false;
                    const normal = new THREE.Vector3();
                    this.camera.getWorldDirection(normal);
                    this.dragPlane.setFromNormalAndCoplanarPoint(normal.negate(), this.draggedNode.position);
                }
            }

            onPointerMove(e) {
                if(!this.draggedNode || this.isSolved) return;
                this.updateMouse(e);
                this.raycaster.setFromCamera(this.mouse, this.camera);
                if(this.raycaster.ray.intersectPlane(this.dragPlane, this.pIntersect)) {
                    this.draggedNode.position.copy(this.pIntersect);
                    
                    // Sadece dÃ¼ÄŸÃ¼m baÅŸlangÄ±Ã§tan 5 birimden fazla hareket ettiyse hasMoved true olsun
                    if (!this.hasMoved && this.dragStartPos.distanceTo(this.draggedNode.position) > 5) {
                        this.hasMoved = true;
                    }
                    
                    let foundSnap = false;
                    let targetIndex = -1;
                    const snapRadius = 9;

                    if(this.strictSnapping) {
                        const assignedIndex = this.draggedNode.userData.targetIndex;
                        const assignedTarget = this.targetPoints[assignedIndex];
                        if(assignedTarget) {
                            const distance = this.draggedNode.position.distanceTo(assignedTarget.pos);
                            if(distance < snapRadius && !this.isTargetOccupied(assignedIndex, this.draggedNode)) {
                                targetIndex = assignedIndex;
                            }
                        }
                    } else {
                        let bestDist = Infinity;
                        this.targetPoints.forEach((tp, idx) => {
                            const dist = this.draggedNode.position.distanceTo(tp.pos);
                            if(dist < snapRadius && dist < bestDist && !this.isTargetOccupied(idx, this.draggedNode)) {
                                bestDist = dist;
                                targetIndex = idx;
                            }
                        });
                    }

                    if(targetIndex >= 0) {
                        const snapPos = this.targetPoints[targetIndex].pos;
                        this.draggedNode.position.copy(snapPos);
                        if (this.draggedNode.userData.currentTarget !== targetIndex) {
                            if (this.draggedNode.userData.onRail) {
                                const penalty = this.draggedNode.userData.lastSnapValue || 0;
                                this.levelScore -= penalty;
                                this.showScoreEffect(this.draggedNode.position, -penalty);
                            }
                            this.playSound('snap');
                            this.triggerScore(this.draggedNode);
                        }
                        this.draggedNode.userData.onRail = true;
                        this.draggedNode.userData.currentTarget = targetIndex;
                        foundSnap = true;
                    }

                    if(!foundSnap) {
                        if (this.draggedNode.userData.onRail) {
                            const penalty = this.draggedNode.userData.lastSnapValue || 0;
                            this.levelScore -= penalty;
                            this.showScoreEffect(this.draggedNode.position, -penalty);
                            this.draggedNode.userData.lastSnapValue = 0;
                        }
                        this.draggedNode.userData.onRail = false;
                        this.draggedNode.userData.currentTarget = null;
                    }
                    this.draggedNode.material.color.setHex(foundSnap ? COLORS.snapped : COLORS.normal);
                    this.draggedNode.material.emissive.setHex(foundSnap ? COLORS.snapped : COLORS.normal);
                    this.updateLines();
                    this.updateProgress();
                }
            }

            triggerScore(node) {
                const gain = this.getCurrentReward();
                this.levelScore += gain;
                node.userData.lastSnapValue = gain;
                this.showScoreEffect(node.position, gain);
            }

            showScoreEffect(pos, val) {
                const vector = pos.clone().project(this.camera);
                const div = document.createElement('div');
                div.className = 'score-float';
                if (val < 0) div.style.color = '#ef4444'; 
                div.style.left = (vector.x * 0.5 + 0.5) * window.innerWidth + 'px';
                div.style.top = (vector.y * -0.5 + 0.5) * window.innerHeight + 'px';
                div.innerText = (val > 0 ? "+" : "") + val;
                document.body.appendChild(div);
                setTimeout(() => div.remove(), 1000);
            }

            onPointerUp() {
                if(!this.draggedNode) return;
                if(this.detectCollision(3.0)) {
                    this.triggerCollisionLock();
                    this.hasMoved = false;
                    return;
                }
                this.draggedNode = null;
                this.hasMoved = false; // Bir sonraki sÃ¼rÃ¼kleme iÃ§in sÄ±fÄ±rla
                this.controls.enabled = true;
                
                // ZORUNLU KONTROL: TÃ¼m dÃ¼ÄŸÃ¼mler yerleÅŸmiÅŸ mi + ÅŸekil DOÄRU MU? (Ä°zomorfizm kontrolÃ¼)
                let snappedCount = this.nodes.filter(n => n.userData.onRail).length;
                if(!this.isSolved && snappedCount === this.nodes.length) {
                    if (this.checkIsomorphism()) {
                        this.complete();
                    } else {
                        this.playSound('fail');
                        // TÃ¼m toplarÄ±n yerleÅŸtiÄŸini ama ÅŸeklin yanlÄ±ÅŸ olduÄŸunu kullanÄ±cÄ±ya bildir (opsiyonel)
                        console.log("Åekil yanlÄ±ÅŸ kuruldu! Kenarlar eÅŸleÅŸmiyor."); 
                    }
                }
            }

            // IZOMORFIZM KONTROLÃœ: Mevcut baÄŸlantÄ±larÄ±n hedef ÅŸeklin baÄŸlantÄ±larÄ±yla eÅŸleÅŸip eÅŸleÅŸmediÄŸini kontrol eder
            checkIsomorphism() {
                const data = POLYTOPES[this.currentLevel];
                // EÄŸer seviyede kenar verisi yoksa (Ã¶rn. autoEdge), kontrolÃ¼ pas geÃ§ (her zaman doÄŸru kabul et)
                if (!data.edges) return true;

                // Mevcut yerleÅŸim haritasÄ±: nodeIndex -> targetIndex
                // nodeIndex: edges dizisindeki dÃ¼ÄŸÃ¼m indeksleri
                // targetIndex: targetPoints ve data.edges'deki hedef nokta indeksleri
                const mapping = []; 
                for(let i=0; i<this.nodes.length; i++) {
                    const node = this.nodes[i];
                    if (node.userData.currentTarget === null) return false; // Herhangi biri yerleÅŸmemiÅŸse zaten yanlÄ±ÅŸtÄ±r
                    mapping[i] = node.userData.currentTarget;
                }

                // Hedef kenarlarÄ±n listesi (string olarak 'min-max' formatÄ±nda saklayalÄ±m)
                const targetEdgesSet = new Set();
                data.edges.forEach(e => {
                    const u = e[0], v = e[1];
                    targetEdgesSet.add(Math.min(u,v) + "-" + Math.max(u,v));
                });

                // Mevcut DÃ¼ÄŸÃ¼mlerin oluÅŸturduÄŸu kenarlarÄ± kontrol edelim
                // this.edges dizisi, dÃ¼ÄŸÃ¼mler arasÄ±ndaki fiziksel baÄŸlarÄ± tutar.
                // Bu baÄŸlar (n1, n2) dÃ¼ÄŸÃ¼mleri arasÄ±ndadÄ±r.
                // Biz n1 ve n2'nin yerleÅŸtiÄŸi hedef noktalarÄ± (targetIndex) bulup,
                // bu iki hedef nokta arasÄ±nda gerÃ§ekte bir kenar olmalÄ± mÄ± diye bakacaÄŸÄ±z.
                
                // Oyundaki tÃ¼m kÄ±rmÄ±zÄ± Ã§izgiler (this.edges) hedeflenen kenarlarla (data.edges) uyuÅŸmalÄ±.
                // EÄŸer oyuncunun oluÅŸturduÄŸu bir kenar, hedef ÅŸekilde yoksa -> YANLIÅ ÅEKÄ°L
                
                // 1. ADIM: Oyuncu kenarlarÄ±nÄ±n hedefte karÅŸÄ±lÄ±ÄŸÄ± var mÄ±?
                for (let i = 0; i < this.edges.length; i++) {
                    const edgeObj = this.edges[i];
                    // Bu kenarÄ±n uÃ§larÄ± hangi dÃ¼ÄŸÃ¼mler? (indexlerini bulmamÄ±z lazÄ±m)
                    const idx1 = this.nodes.indexOf(edgeObj.n1);
                    const idx2 = this.nodes.indexOf(edgeObj.n2);
                    
                    if (idx1 === -1 || idx2 === -1) continue; // Hata toleransÄ±

                    // Bu dÃ¼ÄŸÃ¼mler hangi hedeflere oturdu?
                    const t1 = mapping[idx1];
                    const t2 = mapping[idx2];
                    
                    // Bu hedefler arasÄ±nda bir kenar olmalÄ± mÄ±?
                    const key = Math.min(t1,t2) + "-" + Math.max(t1,t2);
                    if (!targetEdgesSet.has(key)) {
                        // Oyuncu, aralarÄ±nda kenar olmamasÄ± gereken iki nokta arasÄ±na kenar koymuÅŸ (Ã§Ã¼nkÃ¼ dÃ¼ÄŸÃ¼mleri yanlÄ±ÅŸ yerleÅŸtirmiÅŸ)
                        return false; 
                    }
                }
                
                return true; 
            }

            updateMouse(e) { this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1; this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1; }

            isTargetOccupied(targetIndex, ignoreNode) {
                return this.nodes.some(n => n !== ignoreNode && n.userData && n.userData.currentTarget === targetIndex);
            }

            openHelp() {
                this.playSound('click');
                const overlay = document.getElementById('help-overlay');
                if(!overlay) return;
                overlay.style.display = 'flex';
                this.helpOpen = true;
                this.draggedNode = null;
                this.hasMoved = false;
                if(this.controls) this.controls.enabled = false;
            }

            closeHelp() {
                this.playSound('click');
                const overlay = document.getElementById('help-overlay');
                if(!overlay) return;
                overlay.style.display = 'none';
                this.helpOpen = false;
                const uiVisible = document.getElementById('ui').style.display !== 'none';
                if(uiVisible && !this.isSolved && this.controls) this.controls.enabled = true;
            }

            updateLines() { 
                this.edges.forEach(e => { 
                    const d = e.n1.position.distanceTo(e.n2.position); 
                    e.mesh.position.copy(e.n1.position); 
                    e.mesh.scale.set(1, 1, d); 
                    e.mesh.lookAt(e.n2.position); 
                }); 
            }

            updateProgress() {
                let snappedCount = this.nodes.filter(n => n.userData.onRail).length;
                let perc = Math.floor((snappedCount / this.nodes.length) * 100);
                document.getElementById('bar-fill').style.width = perc + '%';
                document.getElementById('percent-val').innerText = perc;
            }

            detectCollision(limit) {
                for(let i=0; i<this.edges.length; i++) {
                    for(let j=i+1; j<this.edges.length; j++) {
                        const e1 = this.edges[i], e2 = this.edges[j];
                        if(e1.n1===e2.n1 || e1.n1===e2.n2 || e1.n2===e2.n1 || e1.n2===e2.n2) continue;
                        if(this.getLineDist(e1.n1.position, e1.n2.position, e2.n1.position, e2.n2.position) < limit) return true;
                    }
                } return false;
            }

            triggerCollisionLock() { 
                this.playSound('collision');
                this.draggedNode = null; this.hasMoved = false; this.controls.enabled = false; document.getElementById('collision-lock').style.display = 'flex'; 
            }
            
            restoreSafeState() {
                this.playSound('undo');
                this.nodes.forEach((n, i) => { 
                    n.position.copy(this.lastSafePos[i]); 
                    let snappedIndex = -1;
                    this.targetPoints.forEach((tp, idx) => {
                        if(snappedIndex === -1 && n.position.distanceTo(tp.pos) < 1) snappedIndex = idx;
                    });
                    const isSnapped = snappedIndex >= 0;
                    n.userData.onRail = isSnapped;
                    n.userData.currentTarget = isSnapped ? snappedIndex : null;
                    n.material.color.setHex(isSnapped ? COLORS.snapped : COLORS.normal);
                    n.material.emissive.setHex(isSnapped ? COLORS.snapped : COLORS.normal);
                });
                this.controls.enabled = true; 
                document.getElementById('collision-lock').style.display = 'none'; 
                this.updateLines(); 
                this.updateProgress();
            }

            getLineDist(p1, p2, p3, p4) {
                const u = p2.clone().sub(p1), v = p4.clone().sub(p3), w = p1.clone().sub(p3);
                const a = u.dot(u), b = u.dot(v), c = v.dot(v), d = u.dot(w), e = v.dot(w);
                const D = a*c - b*b; let sc, tc;
                if (D < 0.001) { sc = 0; tc = b > c ? d/b : e/c; } else { sc = (b*e - c*d)/D; tc = (a*e - b*d)/D; }
                return p1.clone().add(u.multiplyScalar(Math.max(0,Math.min(1,sc)))).distanceTo(p3.clone().add(v.multiplyScalar(Math.max(0,Math.min(1,tc)))));
            }

            generateSolvableStart(data) {
                // Ã‡Ã¶zÃ¼lebilir dÃ¼ÄŸÃ¼m yapÄ±sÄ± oluÅŸtur: DÃ¼ÄŸÃ¼mleri permÃ¼tasyon ile karÄ±ÅŸtÄ±r
                // Ã‡akÄ±ÅŸma olmayan bir konfigÃ¼rasyon bulana kadar dene
                
                const nodeCount = this.nodes.length;
                const shuffleLevel = Math.min(5 + this.currentLevel * 2, nodeCount); // KarmaÅŸÄ±klÄ±k
                const maxAttempts = 100;
                let attempt = 0;
                let validConfig = false;
                
                while (!validConfig && attempt < maxAttempts) {
                    attempt++;
                    
                    // Her dÃ¼ÄŸÃ¼me hedef indeksini ata
                    let targetIndices = Array.from({length: nodeCount}, (_, i) => i);
                    
                    // KontrollÃ¼ karÄ±ÅŸtÄ±rma: Sadece komÅŸu olmayan noktalarÄ± takas et
                    for (let shuffle = 0; shuffle < shuffleLevel; shuffle++) {
                        let idx1 = Math.floor(Math.random() * nodeCount);
                        let idx2 = Math.floor(Math.random() * nodeCount);
                        
                        if (idx1 !== idx2 && !this.areTargetNeighbors(idx1, idx2, data)) {
                            [targetIndices[idx1], targetIndices[idx2]] = [targetIndices[idx2], targetIndices[idx1]];
                        }
                    }
                    
                    // DÃ¼ÄŸÃ¼mleri karÄ±ÅŸÄ±k pozisyonlara yerleÅŸtir - gÃ¼venli mesafede
                    const baseOffset = 40 + (this.currentLevel * 4); // Daha uzak baÅŸlangÄ±Ã§
                    
                    this.nodes.forEach((node, i) => {
                        const targetIndex = targetIndices[i];
                        const targetPos = this.targetPoints[targetIndex].pos;
                        node.userData.targetIndex = targetIndex;
                        node.userData.onRail = false;
                        node.userData.currentTarget = null;
                        
                        // Rastgele ama tutarlÄ± bir yÃ¶n oluÅŸtur (seed bazlÄ±)
                        const seed1 = i * 7.13 + targetIndex * 3.71;
                        const seed2 = i * 5.37 + targetIndex * 2.89;
                        
                        const theta = (Math.sin(seed1) * Math.PI * 2);
                        const phi = (Math.cos(seed2) * Math.PI);
                        
                        const direction = new THREE.Vector3(
                            Math.sin(phi) * Math.cos(theta),
                            Math.sin(phi) * Math.sin(theta),
                            Math.cos(phi)
                        );
                        
                        // Her dÃ¼ÄŸÃ¼me farklÄ± varyasyon
                        const variation = Math.sin(i * 11.3 + targetIndex * 7.7) * 10;
                        node.position.copy(targetPos).add(direction.multiplyScalar(baseOffset + variation));
                    });

                    this.updateLines();
                    
                    // BaÅŸlangÄ±Ã§ta Ã§akÄ±ÅŸma var mÄ± kontrol et (Ã§ok gevÅŸek tolerans)
                    if (!this.detectCollision(8.0)) {
                        validConfig = true;
                    }
                }
                
                // EÄŸer uygun konfigÃ¼rasyon bulunamadÄ±ysa, basit daÄŸÄ±lÄ±m kullan
                if (!validConfig) {
                    this.nodes.forEach((node, i) => {
                        node.userData.targetIndex = i;
                        node.userData.onRail = false;
                        node.userData.currentTarget = null;
                        const targetPos = this.targetPoints[i].pos;
                        let direction = targetPos.clone().normalize();
                        if (direction.length() < 0.1) {
                            direction = new THREE.Vector3(
                                Math.cos(i * 2.3), Math.sin(i * 2.3), Math.cos(i * 1.7)
                            ).normalize();
                        }
                        node.position.copy(targetPos).add(direction.multiplyScalar(50 + i * 8));
                    });
                    this.updateLines();
                }
                
                this.lastSafePos = this.nodes.map(n => n.position.clone());
            }

            areTargetNeighbors(idx1, idx2, data) {
                // Ä°ki dÃ¼ÄŸÃ¼mÃ¼n hedef konumlarÄ±nda komÅŸu olup olmadÄ±ÄŸÄ±nÄ± kontrol et
                if (!data.edges) return false;
                return data.edges.some(e => 
                    (e[0] === idx1 && e[1] === idx2) || (e[0] === idx2 && e[1] === idx1)
                );
            }

            complete() {
                this.playSound('win');
                this.isSolved = true; this.isCelebrating = true; this.controls.autoRotate = true;
                const bonus = (this.currentLevel >= 3) ? 500 * Math.pow(2, this.currentLevel - 2) : 500;
                this.levelScore += bonus; this.totalScore += this.levelScore;
                
                const isLastLevel = this.currentLevel === POLYTOPES.length - 1;
                
                if(this.currentLevel === this.unlockedLevel) this.unlockedLevel++;
                localStorage.setItem('polyMax', this.unlockedLevel);
                localStorage.setItem('polyScore', this.totalScore);
                this.updateGlobalUI();
                this.nodes.forEach(n => { n.material.color.setHex(0xffd700); n.material.emissiveIntensity = 1; });
                this.edges.forEach(e => { e.mesh.material.color.setHex(0xffd700); e.mesh.material.emissiveIntensity = 1; });
                if(this.surfaceMesh) { 
                    this.surfaceMesh.material.opacity = 0.5; 
                    this.surfaceMesh.material.color.setHex(0x4ade80); 
                    this.surfaceMesh.material.depthWrite = true; // KazanÄ±nca yÃ¼zeyi netleÅŸtir
                }
                
                if (isLastLevel) {
                    this.triggerFireworks();
                }

                setTimeout(() => {
                    document.getElementById('win-screen').style.display = 'flex';
                    if (isLastLevel) {
                        document.getElementById('win-title').innerText = "TÃœM SEVÄ°YELER TAMAMLANDI!";
                        document.getElementById('next-btn').innerText = "TEKRAR OYNA â†º";
                        document.getElementById('next-btn').onclick = () => { location.reload(); };
                    }
                    document.getElementById('win-stats').innerHTML = `SKOR: ${this.levelScore} <br> <span style="font-size:0.8rem; color:var(--gold)">+${bonus} BONUS PUAN</span>`;
                }, 2000);
            }

            triggerFireworks() {
                const container = document.getElementById('fireworks-container');
                container.style.display = 'block';
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => this.createFirework(), i * 300);
                }
                setTimeout(() => { container.style.display = 'none'; container.innerHTML = ''; }, 10000);
            }

            createFirework() {
                const container = document.getElementById('fireworks-container');
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffffff'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                for (let i = 0; i < 30; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'absolute';
                    particle.style.left = x + 'px';
                    particle.style.top = y + 'px';
                    particle.style.width = '4px';
                    particle.style.height = '4px';
                    particle.style.borderRadius = '50%';
                    particle.style.backgroundColor = color;
                    particle.style.boxShadow = `0 0 10px ${color}`;
                    
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 5 + 2;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    
                    container.appendChild(particle);
                    
                    let opacity = 1;
                    const anim = () => {
                        const curX = parseFloat(particle.style.left);
                        const curY = parseFloat(particle.style.top);
                        particle.style.left = (curX + vx) + 'px';
                        particle.style.top = (curY + vy) + 'px';
                        opacity -= 0.02;
                        particle.style.opacity = opacity;
                        if (opacity > 0) requestAnimationFrame(anim);
                        else particle.remove();
                    };
                    requestAnimationFrame(anim);
                }
            }

            resetData() { 
                this.playSound('click');
                document.getElementById('reset-modal').style.display = 'flex';
            }
            confirmReset() {
                localStorage.clear(); 
                location.reload();
            }
            closeResetModal() {
                this.playSound('click');
                document.getElementById('reset-modal').style.display = 'none';
            }
            nextLevel() { 
                this.playSound('click');
                this.currentLevel = Math.min(this.currentLevel + 1, POLYTOPES.length - 1); 
                this.startLevel(); 
            }

            useJoker() {
                if(this.isSolved || this.jokerUsed) return;
                this.playSound('snap');
                this.jokerUsed = true;
                document.getElementById('joker-btn').style.display = 'none';

                // Puan eksiltme: Joker kullanÄ±ldÄ±ÄŸÄ±nda o anki puanÄ±n yarÄ±sÄ± silinir
                if (this.levelScore > 0) {
                    const penalty = Math.floor(this.levelScore / 2);
                    this.levelScore -= penalty;
                    this.showScoreEffect(this.camera.position, -penalty); 
                }

                // HenÃ¼z yerleÅŸmemiÅŸ bir dÃ¼ÄŸÃ¼m bul
                const node = this.nodes.find(n => !n.userData.onRail);
                if (node) {
                    const tidx = node.userData.targetIndex;
                    const targetPos = this.targetPoints[tidx].pos;
                    
                    node.position.copy(targetPos);
                    node.userData.onRail = true;
                    node.userData.currentTarget = tidx;
                    node.userData.lastSnapValue = 0; 
                    node.material.color.setHex(COLORS.snapped);
                    node.material.emissive.setHex(COLORS.snapped);
                    
                    this.updateLines();
                    this.updateProgress();

                    // Seviye bitti mi kontrol et
                    let snappedCount = this.nodes.filter(n => n.userData.onRail).length;
                    if(snappedCount === this.nodes.length && this.checkIsomorphism()) {
                        this.complete();
                        return;
                    }

                    // Ã‡akÄ±ÅŸma yoksa gÃ¼venli noktayÄ± gÃ¼ncelle
                    if (!this.detectCollision(3.0)) {
                        this.lastSafePos = this.nodes.map(n => n.position.clone());
                    }
                    
                    this.showScoreEffect(node.position, "JOKER");
                }
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.updatePanelResponsive();
            }

            animate() { 
                requestAnimationFrame(() => this.animate()); 
                this.controls.update(); 
                
                if (this.stars) {
                    this.stars.position.copy(this.camera.position);
                    this.stars.rotation.y += 0.00035;
                    this.stars.rotation.x += 0.00012;
                }

                if(!this.isSolved && this.startTime) {
                    const elapsed = (Date.now() - this.startTime) / 1000;
                    const data = POLYTOPES[this.currentLevel];
                    const rem = Math.max(0, data.time - (elapsed % data.time));
                    document.getElementById('timer-display').innerText = rem.toFixed(1);
                    document.getElementById('current-reward').innerText = this.getCurrentReward();
                    const glow = 0.3 + Math.sin(Date.now() * 0.005) * 0.2;
                    this.edges.forEach(e => e.mesh.material.emissiveIntensity = glow);
                }
                this.renderer.render(this.scene, this.camera); 
            }
        }
        const game = new Game();
    </script>
</body>
</html>