<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TopoLogic Pro: Ultimate Simulation</title>
    <style>
        body { margin: 0; background: #000; color: #0f0; font-family: 'Segoe UI', sans-serif; overflow: hidden; touch-action: none; }
        
        /* SOL PANEL: DURUM VE PUAN */
        #ui-main { position: absolute; top: 15px; left: 15px; width: calc(100% - 100px); max-width: 350px; pointer-events: none; z-index: 10; }
        .panel { background: rgba(0,30,0,0.92); border: 2px solid #0f0; padding: 15px; border-radius: 12px; box-shadow: 0 0 30px rgba(0,255,0,0.3); }
        .bar-bg { background: #111; height: 12px; border-radius: 6px; margin: 10px 0; border: 1px solid #040; overflow: hidden; }
        #bar-fill { background: #0f0; height: 100%; width: 0%; transition: width 0.3s; }
        #level-title { font-weight: bold; font-size: 18px; color: #fff; text-transform: uppercase; letter-spacing: 1px; }
        
        /* SAĞ PANEL: SEVİYE SEÇİCİ */
        #level-selector { position: absolute; right: 15px; top: 15px; bottom: 15px; width: 65px; display: flex; flex-direction: column; gap: 10px; z-index: 20; overflow-y: auto; padding-right: 5px; scrollbar-width: none; }
        #level-selector::-webkit-scrollbar { display: none; }
        .lvl-btn { pointer-events: auto; width: 55px; height: 55px; background: rgba(0,20,0,0.9); border: 2px solid #0f0; color: #0f0; border-radius: 10px; font-weight: bold; cursor: pointer; font-size: 12px; display: flex; align-items: center; justify-content: center; transition: 0.3s; }
        .lvl-btn:hover { background: #0f0; color: #000; box-shadow: 0 0 15px #0f0; }
        .lvl-btn.active { background: #0f0; color: #000; transform: scale(1.1); box-shadow: 0 0 20px #0f0; }

        /* ZAFER EKRANI */
        #win-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; backdrop-filter: blur(10px); }
        .big-btn { pointer-events: auto; background: #0f0; color: #000; border: none; padding: 18px 45px; font-weight: bold; cursor: pointer; border-radius: 12px; font-size: 22px; box-shadow: 0 0 20px #0f0; }
        
        #warning { color: #f00; font-weight: bold; font-size: 13px; display: none; margin-top: 8px; border: 1px solid red; padding: 5px; background: rgba(255,0,0,0.1); text-align: center; }
    </style>
</head>
<body>

    <div id="ui-main" class="panel">
        <div id="level-title">YÜKLENİYOR...</div>
        <div class="bar-bg"><div id="bar-fill"></div></div>
        <div style="display: flex; justify-content: space-between; font-size: 14px;">
            <span>UYUMLULUK: %<span id="percent-val">0</span></span>
            <span>SKOR: <span id="score-val">1000</span></span>
        </div>
        <div id="warning">TOPOLOJİK ENGEL: İÇİNDEN GEÇEMEZSİN!</div>
    </div>

    <div id="level-selector"></div>

    <div id="win-screen">
        <h1 style="color:#0f0; font-size: 48px; margin-bottom: 10px;">BÖLÜM TAMAM!</h1>
        <p id="win-desc" style="color:#fff; text-align:center; max-width: 80%; line-height: 1.5; margin-bottom: 30px;"></p>
        <button class="big-btn" id="next-btn">SIRADAKİ HEDEF</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { DragControls } from 'three/addons/controls/DragControls.js';

        let scene, camera, renderer, controls, dragControls;
        let knotMesh, ghostMesh, knotCurve, handles = [];
        let targetPoints = [];
        let currentLevelIndex = 0;
        let lastSafePos = new THREE.Vector3();
        let gameScore = 1000;

        const levels = [
            // LEVEL 1: Unknot (DüğümSüz) Dönüşümleri
            { name: "1.1: Halka", type: 'circle', nodes: 12, radius: 8, desc: "Basit bir halka. Hiçbir düğümü yok.", threshold: 0.8 },
            { name: "1.2: Yıldız", type: 'star', nodes: 20, radius: 8, desc: "Halkayı yıldıza dönüştürdün. Geometri değişti ama topoloji aynı kaldı!", threshold: 0.6 },
            
            // LEVEL 2: Trefoil (Yonca) İzotopileri
            { name: "2.1: Yonca Düğümü", type: 'trefoil', nodes: 18, p: 2, q: 3, radius: 7, desc: "Bu gerçek bir düğümdür (3_1). Kesilmeden çözülemez!", threshold: 0.7 },
            { name: "2.2: Aşk Düğümü", type: 'trefoil_heart', nodes: 20, p: 2, q: 3, radius: 0.5, desc: "Düğümü bir kalp formuna soktun. Düğümün özü hala bir Yonca!", threshold: 0.6 },
            
            // LEVEL 3: Figure-8
            { name: "3.1: Sekizli Düğüm", type: 'figure8', nodes: 24, p: 2, q: 5, radius: 7, desc: "Sekizli Düğüm (4_1). Matematiksel olarak mükemmel bir simetri.", threshold: 0.6 }
        ];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 25);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.GridHelper(50, 50, 0x004400, 0x001100));
            scene.add(new THREE.AmbientLight(0xffffff, 1.0));
            const light = new THREE.PointLight(0x00ffcc, 1500);
            light.position.set(10, 25, 10);
            scene.add(light);

            // MENÜ OLUŞTUR
            const menu = document.getElementById('level-selector');
            levels.forEach((lvl, idx) => {
                const btn = document.createElement('button');
                btn.className = 'lvl-btn';
                btn.innerText = lvl.name.split(":")[0];
                btn.onclick = () => loadLevel(idx);
                menu.appendChild(btn);
            });

            loadLevel(currentLevelIndex);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.rotateSpeed = 0.6;

            document.getElementById('next-btn').onclick = () => {
                loadLevel((currentLevelIndex + 1) % levels.length);
            };

            window.addEventListener('resize', onWindowResize);
        }

        function getShapePoint(t, level) {
            const r0 = level.radius;
            if (level.type === 'circle') return new THREE.Vector3(Math.cos(t) * r0, 0, Math.sin(t) * r0);
            if (level.type === 'star') {
                const rs = r0 + 2.5 * Math.sin(5 * t);
                return new THREE.Vector3(rs * Math.cos(t), 0, rs * Math.sin(t));
            }
            if (level.type === 'trefoil_heart') {
                const rth = 0.5 * (2 + Math.sin(3 * t));
                return new THREE.Vector3(16*Math.pow(Math.sin(t),3)*r0 + rth*Math.cos(2*t), (13*Math.cos(t)-5*Math.cos(2*t))*r0 + rth*Math.sin(2*t), Math.cos(3*t)*5);
            }
            const r = 0.5 * (2 + Math.sin(level.q * t));
            return new THREE.Vector3(r * Math.cos(level.p * t) * r0, r * Math.sin(level.p * t) * r0, Math.cos(level.q * t) * r0);
        }

        function loadLevel(idx) {
            currentLevelIndex = idx;
            const level = levels[idx];
            document.getElementById('win-screen').style.display = 'none';
            document.getElementById('level-title').innerText = level.name;
            gameScore = 1000;

            document.querySelectorAll('.lvl-btn').forEach((b, i) => b.className = (i === idx) ? 'lvl-btn active' : 'lvl-btn');
            
            handles.forEach(h => scene.remove(h));
            handles = [];
            if (knotMesh) scene.remove(knotMesh);
            if (ghostMesh) scene.remove(ghostMesh);
            targetPoints = [];

            // 1. GHOST TARGET
            const gPts = [];
            for(let i=0; i<120; i++) gPts.push(getShapePoint((i/120)*Math.PI*2, level));
            ghostMesh = new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(gPts, true), 100, 0.12, 6, true), 
                new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.1, wireframe: true }));
            scene.add(ghostMesh);

            // 2. TARGET POINTS
            for(let i=0; i < level.nodes; i++) {
                const tp = getShapePoint((i / level.nodes) * Math.PI * 2, level);
                targetPoints.push(tp);
                const handle = new THREE.Mesh(new THREE.SphereGeometry(1.5, 8, 8), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
                const visual = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                handle.add(visual);
                handle.position.set(tp.x + (Math.random()-0.5)*15, tp.y + (Math.random()-0.5)*15, tp.z + (Math.random()-0.5)*15);
                scene.add(handle);
                handles.push(handle);
            }

            knotCurve = new THREE.CatmullRomCurve3(handles.map(h => h.position), true);
            updateKnot();

            if (dragControls) dragControls.dispose();
            dragControls = new DragControls(handles, camera, renderer.domElement);
            
            dragControls.addEventListener('dragstart', (e) => { controls.enabled = false; lastSafePos.copy(e.object.position); });
            dragControls.addEventListener('drag', (e) => {
                if (checkIntersection()) {
                    const bounce = new THREE.Vector3().subVectors(lastSafePos, e.object.position).normalize().multiplyScalar(0.06);
                    e.object.position.copy(lastSafePos).add(bounce);
                    document.getElementById('warning').style.display = 'block';
                    gameScore = Math.max(0, gameScore - 1);
                } else {
                    lastSafePos.copy(e.object.position);
                    document.getElementById('warning').style.display = 'none';
                }
                updateKnot();
            });
            dragControls.addEventListener('dragend', (e) => {
                controls.enabled = true;
                let hIdx = handles.indexOf(e.object);
                if (hIdx !== -1 && e.object.position.distanceTo(targetPoints[hIdx]) < 2.5) e.object.position.copy(targetPoints[hIdx]);
                updateKnot();
                checkWin();
            });
        }

        function checkIntersection() {
            const pts = knotCurve.getPoints(100);
            const skip = 22;
            const threshold = levels[currentLevelIndex].threshold;
            for(let i=0; i < pts.length; i++) {
                for(let j=i + skip; j < pts.length; j++) {
                    if (i < skip && j > pts.length - skip) continue;
                    if (pts[i].distanceTo(pts[j]) < threshold) return true;
                }
            }
            return false;
        }

        function updateKnot() {
            if (knotMesh) scene.remove(knotMesh);
            knotCurve.points = handles.map(h => h.position);
            const tubeGeom = new THREE.TubeGeometry(knotCurve, 100, 0.4, 8, true);
            knotMesh = new THREE.Mesh(tubeGeom, new THREE.MeshStandardMaterial({ color: 0x00ffcc, metalness: 0.8, roughness: 0.2 }));
            scene.add(knotMesh);
            let totalDist = 0;
            handles.forEach((h, i) => {
                let d = h.position.distanceTo(targetPoints[i]);
                totalDist += d;
                if (h.children[0]) h.children[0].material.color.set(d < 1.0 ? 0x00ff00 : (d < 4 ? 0xffff00 : 0xff0000));
            });
            let percent = Math.max(0, 100 - (totalDist * 0.7));
            document.getElementById('bar-fill').style.width = percent + '%';
            document.getElementById('percent-val').innerText = Math.floor(percent);
            document.getElementById('score-val').innerText = Math.floor(gameScore);
        }

        function checkWin() {
            let totalDist = 0;
            handles.forEach((h, i) => totalDist += h.position.distanceTo(targetPoints[i]));
            if (totalDist < 4.5 && !checkIntersection()) {
                document.getElementById('win-screen').style.display = 'flex';
                document.getElementById('win-desc').innerText = levels[currentLevelIndex].desc;
            }
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    </script>
</body>
</html>