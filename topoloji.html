<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>TopoLogic: Akıllı Kilit Sistemi</title>
    <style>
        body { margin: 0; background: #000; color: #0f0; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        #ui { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); width: 450px; text-align: center; pointer-events: none; }
        .panel { background: rgba(0,25,0,0.95); border: 2px solid #0f0; padding: 20px; border-radius: 12px; box-shadow: 0 0 30px rgba(0,255,0,0.3); }
        .bar-bg { background: #111; height: 12px; border-radius: 6px; margin: 10px 0; border: 1px solid #040; overflow: hidden; }
        #bar-fill { background: #0f0; height: 100%; width: 0%; transition: width 0.3s; }
        #warning { color: #f00; font-weight: bold; font-size: 15px; margin-top: 10px; display: none; text-shadow: 0 0 10px #f00; border: 1px solid red; padding: 5px; background: rgba(255,0,0,0.1); }
        #win-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); 
                     display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; }
        button { pointer-events: auto; background: #0f0; color: #000; border: none; padding: 15px 40px; font-weight: bold; cursor: pointer; border-radius: 8px; font-size: 18px; }
    </style>
</head>
<body>

    <div id="ui" class="panel">
        <div id="level-title" style="font-weight: bold; font-size: 20px;">YÜKLENİYOR...</div>
        <div id="progress-text">UYUMLULUK: %0</div>
        <div class="bar-bg"><div id="bar-fill"></div></div>
        <div id="warning">DİKKAT: İÇİNDEN GEÇİLEMEZ! (HAREKET BLOKE EDİLDİ)</div>
        <div style="font-size: 11px; color: #8f8; margin-top: 8px;">İpucu: Sıkışırsanız noktayı aksi yöne çekin.</div>
    </div>

    <div id="win-screen">
        <h1 style="color:#0f0; font-size: 60px; margin: 0;">MÜKEMMEL!</h1>
        <button id="next-btn">SONRAKİ SEVİYE</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { DragControls } from 'three/addons/controls/DragControls.js';

        let scene, camera, renderer, controls, dragControls;
        let knotMesh, ghostMesh, knotCurve, handles = [];
        let targetPoints = [];
        let currentLevel = 0;
        let safePosition = new THREE.Vector3(); // Sıkışmayı önleyen yedek konum

        const levels = [
            { name: "Halka (Unknot)", nodes: 12, radius: 8, p: 0, q: 0 },
            { name: "Yonca Düğümü (Trefoil)", nodes: 18, radius: 7, p: 2, q: 3 },
            { name: "Sekizli Düğüm (Figure-8)", nodes: 22, radius: 7, p: 2, q: 5 }
        ];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 18, 25);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.GridHelper(50, 50, 0x004400, 0x001100));
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const sun = new THREE.DirectionalLight(0x00ffcc, 1);
            sun.position.set(10, 20, 10);
            scene.add(sun);

            loadLevel(currentLevel);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            document.getElementById('next-btn').onclick = () => {
                currentLevel = (currentLevel + 1) % levels.length;
                loadLevel(currentLevel);
            };

            window.addEventListener('resize', onWindowResize);
        }

        function getKnotPoint(t, idx) {
            const l = levels[idx];
            if (idx === 0) return new THREE.Vector3(Math.cos(t) * l.radius, 0, Math.sin(t) * l.radius);
            const r = 0.5 * (2 + Math.sin(l.q * t));
            return new THREE.Vector3(r * Math.cos(l.p * t) * l.radius, r * Math.sin(l.p * t) * l.radius, Math.cos(l.q * t) * l.radius);
        }

        function loadLevel(idx) {
            const level = levels[idx];
            document.getElementById('win-screen').style.display = 'none';
            document.getElementById('level-title').innerText = `LEVEL ${idx + 1}: ${level.name}`;
            
            handles.forEach(h => scene.remove(h));
            handles = [];
            if (knotMesh) scene.remove(knotMesh);
            if (ghostMesh) scene.remove(ghostMesh);
            targetPoints = [];

            // 1. Ghost Hedef
            const gPts = [];
            for(let i=0; i<120; i++) gPts.push(getKnotPoint((i/120)*Math.PI*2, idx));
            ghostMesh = new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(gPts, true), 128, 0.1, 8, true), 
                new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.1, wireframe: true }));
            scene.add(ghostMesh);

            // 2. Noktalar
            for(let i=0; i<level.nodes; i++) {
                const tp = getKnotPoint((i/level.nodes)*Math.PI*2, idx);
                targetPoints.push(tp);
                const handle = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                handle.position.set(tp.x + (Math.random()-0.5)*10, tp.y + (Math.random()-0.5)*10, tp.z + (Math.random()-0.5)*10);
                scene.add(handle);
                handles.push(handle);
            }

            knotCurve = new THREE.CatmullRomCurve3(handles.map(h => h.position), true);
            updateKnot();

            if (dragControls) dragControls.dispose();
            dragControls = new DragControls(handles, camera, renderer.domElement);
            
            dragControls.addEventListener('dragstart', (e) => {
                controls.enabled = false;
                safePosition.copy(e.object.position); // Hareket başlangıcını kaydet
            });

            dragControls.addEventListener('drag', (e) => {
                const intersect = checkIntersection();
                if (intersect) {
                    // KİLİTLENMEYİ ÖNLEYEN MANTIK: 
                    // Eğer çarparsak objeyi eski konuma "ışınlamıyoruz", sadece ilerlemesini durduruyoruz.
                    e.object.position.copy(safePosition);
                    document.getElementById('warning').style.display = 'block';
                } else {
                    // Güvenli alanı güncelle
                    safePosition.copy(e.object.position);
                    document.getElementById('warning').style.display = 'none';
                }
                updateKnot();
            });

            dragControls.addEventListener('dragend', (e) => {
                controls.enabled = true;
                let hIdx = handles.indexOf(e.object);
                if (e.object.position.distanceTo(targetPoints[hIdx]) < 1.8) {
                    e.object.position.copy(targetPoints[hIdx]);
                }
                updateKnot();
                checkWin();
            });
        }

        function checkIntersection() {
            const pts = knotCurve.getPoints(150);
            const skip = 20;
            for(let i=0; i < pts.length; i++) {
                for(let j=i + skip; j < pts.length; j++) {
                    if (i < skip && j > pts.length - skip) continue;
                    // Hassasiyeti biraz gevşettik (0.8) ki "kilitlenme" olmasın
                    if (pts[i].distanceTo(pts[j]) < 0.8) return true;
                }
            }
            return false;
        }

        function updateKnot() {
            if (knotMesh) scene.remove(knotMesh);
            knotCurve.points = handles.map(h => h.position);
            const isErr = checkIntersection();
            knotMesh = new THREE.Mesh(new THREE.TubeGeometry(knotCurve, 128, 0.4, 10, true), 
                new THREE.MeshStandardMaterial({ color: isErr ? 0xff3300 : 0x00ffcc, metalness: 0.8 }));
            scene.add(knotMesh);

            let totalDist = 0;
            handles.forEach((h, i) => {
                let d = h.position.distanceTo(targetPoints[i]);
                totalDist += d;
                h.material.color.set(d < 0.8 ? 0x00ff00 : (d < 3 ? 0xffff00 : 0xff0000));
            });

            let score = Math.max(0, 100 - (totalDist * 1.1));
            if (isErr) score *= 0.2; 
            document.getElementById('bar-fill').style.width = score + '%';
            document.getElementById('progress-text').innerText = `UYUMLULUK: %${Math.floor(score)}`;
        }

        function checkWin() {
            let totalDist = 0;
            handles.forEach((h, i) => totalDist += h.position.distanceTo(targetPoints[i]));
            if (totalDist < 2.5 && !checkIntersection()) {
                document.getElementById('win-screen').style.display = 'flex';
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>