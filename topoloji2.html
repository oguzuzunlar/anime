<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TopoLogic: Ultimate Evolution</title>
    <style>
        body { margin: 0; background: #000; color: #0f0; font-family: 'Segoe UI', sans-serif; overflow: hidden; touch-action: none; }
        #ui { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); width: 92%; max-width: 480px; text-align: center; pointer-events: none; z-index: 10; }
        .panel { background: rgba(0,30,0,0.95); border: 2px solid #0f0; padding: 12px; border-radius: 15px; box-shadow: 0 0 25px rgba(0,255,0,0.4); }
        .bar-bg { background: #111; height: 10px; border-radius: 5px; margin: 10px 0; overflow: hidden; border: 1px solid #040; }
        #bar-fill { background: #0f0; height: 100%; width: 0%; transition: width 0.3s; }
        #level-info { font-weight: bold; font-size: 18px; color: #fff; margin-bottom: 5px; text-transform: uppercase; }
        #stats { display: flex; justify-content: space-around; font-size: 14px; margin-bottom: 5px; color: #8f8; }
        #warning { color: #f00; font-weight: bold; font-size: 14px; display: none; margin-top: 5px; border: 1px solid red; padding: 4px; background: rgba(255,0,0,0.1); }
        
        #win-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.92); 
                     display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; backdrop-filter: blur(8px); }
        #win-screen h1 { font-size: 40px; color: #0f0; margin: 0; text-shadow: 0 0 15px #0f0; text-align: center;}
        button { pointer-events: auto; background: #0f0; color: #000; border: none; padding: 15px 40px; font-weight: bold; cursor: pointer; border-radius: 10px; font-size: 20px; margin-top: 25px; box-shadow: 0 5px 15px rgba(0,255,0,0.4); }
        .hint-text { color: #8f8; font-size: 14px; margin-top: 10px; font-style: italic; }
    </style>
</head>
<body>

    <div id="ui" class="panel">
        <div id="level-info">BÖLÜM 1.1</div>
        <div class="bar-bg"><div id="bar-fill"></div></div>
        <div id="stats">
            <div>SKOR: <span id="score-val">1000</span></div>
            <div>UYUMLULUK: %<span id="percent-val">0</span></div>
        </div>
        <div id="warning">ENGEL: İÇİNDEN GEÇEMEZSİN!</div>
    </div>

    <div id="win-screen">
        <h1 id="win-title">MÜKEMMEL!</h1>
        <p id="win-desc" style="color:#fff; font-size: 18px; text-align:center; padding: 0 20px;"></p>
        <p class="hint-text" id="win-hint"></p>
        <button id="next-btn">SIRADAKİ HEDEF</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { DragControls } from 'three/addons/controls/DragControls.js';

        let scene, camera, renderer, controls, dragControls;
        let knotMesh, ghostMesh, knotCurve, handles = [];
        let targetPoints = [];
        let currentLevelIndex = 0;
        let lastValidPos = new THREE.Vector3();
        let gameScore = 1000;

        const levels = [
            // LEVEL 1 GRUBU: Unknot (DüğümSüz) Dönüşümleri
            { name: "1.1: Halka (Daire)", type: 'circle', nodes: 12, radius: 8, desc: "Temel topolojik birim.", hint: "Bu bir 'Unknot'tur." },
            { name: "1.2: Kalp Formu", type: 'heart_unknot', nodes: 16, radius: 0.6, desc: "Dairenin bir kalbe dönüşümü.", hint: "Hala topolojik olarak bir halkadasın." },
            { name: "1.3: Yıldız Formu", type: 'star_unknot', nodes: 20, radius: 8, desc: "Halkanın köşeli bir forma dönüşümü.", hint: "Geometri değişir, topoloji kalır!" },
            
            // LEVEL 2 GRUBU: Trefoil Knot (Yonca Düğümü) İzotopileri
            { name: "2.1: Standart Yonca", type: 'trefoil_classic', nodes: 18, p: 2, q: 3, radius: 7, desc: "En basit gerçek düğüm.", hint: "Bu düğüm kesilmeden çözülemez!" },
            { name: "2.2: Aşk Düğümü", type: 'trefoil_heart', nodes: 20, p: 2, q: 3, radius: 0.5, desc: "Yonca düğümünün kalp formu.", hint: "Düğüm yapısı aynı, sadece dış hatlar değişti." },
            { name: "2.3: Yörünge Düğümü", type: 'trefoil_torus', nodes: 24, p: 2, q: 3, radius: 8, desc: "Bir simit (torus) etrafındaki yonca.", hint: "Torus düğümleri uzayda böyle dolanır." },
            
            // LEVEL 3: Figure-8
            { name: "3.1: Sekizli Düğüm", type: 'figure8', nodes: 24, p: 2, q: 5, radius: 7, desc: "Daha karmaşık, simetrik bir düğüm.", hint: "Sekizli düğüm (4_1) dünyasına hoş geldin." }
        ];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 32);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.GridHelper(50, 50, 0x004400, 0x001100));
            scene.add(new THREE.AmbientLight(0xffffff, 0.9));
            const sun = new THREE.PointLight(0x00ffcc, 1200);
            sun.position.set(15, 25, 15);
            scene.add(sun);

            loadLevel(currentLevelIndex);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.rotateSpeed = 0.7;

            document.getElementById('next-btn').onclick = () => {
                currentLevelIndex = (currentLevelIndex + 1) % levels.length;
                loadLevel(currentLevelIndex);
            };

            window.addEventListener('resize', onWindowResize);
        }

        // MATEMATİKSEL ŞEKİL MOTORU
        function getShapePoint(t, level) {
            const r0 = level.radius;
            switch(level.type) {
                case 'circle': 
                    return new THREE.Vector3(Math.cos(t) * r0, 0, Math.sin(t) * r0);
                case 'heart_unknot':
                    return new THREE.Vector3(16*Math.pow(Math.sin(t),3)*r0, (13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t))*r0, 0);
                case 'star_unknot':
                    const rs = r0 + 2.5 * Math.sin(5 * t);
                    return new THREE.Vector3(rs * Math.cos(t), 0, rs * Math.sin(t));
                case 'trefoil_classic':
                    const rt = 0.5 * (2 + Math.sin(3 * t));
                    return new THREE.Vector3(rt * Math.cos(2 * t) * r0, rt * Math.sin(2 * t) * r0, Math.cos(3 * t) * r0);
                case 'trefoil_heart':
                    // Yonca düğümünü bir kalp kalıbına sokuyoruz
                    const rth = 0.5 * (2 + Math.sin(3 * t));
                    const base_x = rth * Math.cos(2 * t);
                    const base_y = rth * Math.sin(2 * t);
                    return new THREE.Vector3(16*Math.pow(Math.sin(t),3)*r0 + base_x, (13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t))*r0 + base_y, Math.cos(3 * t) * 5);
                case 'trefoil_torus':
                    // Torus (Simit) yüzeyi sarmalı
                    const R = r0, r_torus = 3;
                    return new THREE.Vector3((R + r_torus * Math.cos(3*t)) * Math.cos(2*t), (R + r_torus * Math.cos(3*t)) * Math.sin(2*t), r_torus * Math.sin(3*t));
                case 'figure8':
                    const rf8 = 0.5 * (2 + Math.sin(5 * t));
                    return new THREE.Vector3(rf8 * Math.cos(2 * t) * r0, rf8 * Math.sin(2 * t) * r0, Math.cos(5 * t) * r0);
                default:
                    return new THREE.Vector3(Math.cos(t)*r0, 0, Math.sin(t)*r0);
            }
        }

        function loadLevel(idx) {
            const level = levels[idx];
            document.getElementById('win-screen').style.display = 'none';
            document.getElementById('level-info').innerText = `BÖLÜM ${level.name}`;
            gameScore = 1000;
            
            handles.forEach(h => scene.remove(h));
            handles = [];
            if (knotMesh) scene.remove(knotMesh);
            if (ghostMesh) scene.remove(ghostMesh);
            targetPoints = [];

            // 1. Ghost Target
            const gPts = [];
            for(let i=0; i<120; i++) gPts.push(getShapePoint((i/120)*Math.PI*2, level));
            ghostMesh = new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(gPts, true), 100, 0.15, 6, true), 
                new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.15, wireframe: true }));
            scene.add(ghostMesh);

            // 2. Hedef Noktalar
            for(let i=0; i < level.nodes; i++) {
                targetPoints.push(getShapePoint((i / level.nodes) * Math.PI * 2, level));
            }

            // 3. Etkileşimli Noktalar
            for (let i = 0; i < level.nodes; i++) {
                const handle = new THREE.Mesh(new THREE.SphereGeometry(1.4, 8, 8), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
                const visual = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                handle.add(visual);

                const tp = targetPoints[i];
                handle.position.set(tp.x + (Math.random()-0.5)*12, tp.y + (Math.random()-0.5)*12, tp.z + (Math.random()-0.5)*12);
                scene.add(handle);
                handles.push(handle);
            }

            knotCurve = new THREE.CatmullRomCurve3(handles.map(h => h.position), true);
            updateKnot();

            if (dragControls) dragControls.dispose();
            dragControls = new DragControls(handles, camera, renderer.domElement);
            
            dragControls.addEventListener('dragstart', (e) => {
                controls.enabled = false;
                if(e.object) lastValidPos.copy(e.object.position);
            });

            dragControls.addEventListener('drag', (e) => {
                if(!e.object) return;
                if (checkIntersection()) {
                    e.object.position.copy(lastValidPos);
                    document.getElementById('warning').style.display = 'block';
                    gameScore = Math.max(0, gameScore - 1);
                } else {
                    lastValidPos.copy(e.object.position);
                    document.getElementById('warning').style.display = 'none';
                }
                updateKnot();
            });

            dragControls.addEventListener('dragend', (e) => {
                controls.enabled = true;
                if(!e.object) return;
                let hIdx = handles.indexOf(e.object);
                if (hIdx !== -1 && e.object.position.distanceTo(targetPoints[hIdx]) < 2.5) {
                    e.object.position.copy(targetPoints[hIdx]);
                }
                updateKnot();
                checkWin();
            });
        }

        function checkIntersection() {
            const pts = knotCurve.getPoints(100);
            const skip = 20;
            for(let i=0; i < pts.length; i++) {
                for(let j=i + skip; j < pts.length; j++) {
                    if (i < skip && j > pts.length - skip) continue;
                    if (pts[i].distanceTo(pts[j]) < 0.75) return true;
                }
            }
            return false;
        }

        function updateKnot() {
            if (knotMesh) scene.remove(knotMesh);
            knotCurve.points = handles.map(h => h.position);
            const tubeGeom = new THREE.TubeGeometry(knotCurve, 100, 0.4, 8, true);
            knotMesh = new THREE.Mesh(tubeGeom, new THREE.MeshStandardMaterial({ color: 0x00ffcc, metalness: 0.8 }));
            scene.add(knotMesh);

            let totalDist = 0;
            handles.forEach((h, i) => {
                let d = h.position.distanceTo(targetPoints[i]);
                totalDist += d;
                if (h.children[0]) h.children[0].material.color.set(d < 0.8 ? 0x00ff00 : (d < 3 ? 0xffff00 : 0xff0000));
            });

            let percent = Math.max(0, 100 - (totalDist * 0.8));
            document.getElementById('bar-fill').style.width = percent + '%';
            document.getElementById('percent-val').innerText = Math.floor(percent);
            document.getElementById('score-val').innerText = Math.floor(gameScore);
        }

        function checkWin() {
            let totalDist = 0;
            handles.forEach((h, i) => totalDist += h.position.distanceTo(targetPoints[i]));
            if (totalDist < 4.0 && !checkIntersection()) {
                const level = levels[currentLevelIndex];
                document.getElementById('win-screen').style.display = 'flex';
                document.getElementById('win-desc').innerText = level.desc;
                document.getElementById('win-hint').innerText = level.hint;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>